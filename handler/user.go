// Code generated by apigen. DO NOT EDIT.
// GENERATED: 2025-10-06T09:05:32+07:00

package handler

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strconv"
	"time"

	"hanoman.co.id/crudgen/model"
)

func UserHandlerRegister(mux *http.ServeMux, store model.Store, authenticate Authenticate) {
	mux.HandleFunc("PUT /User", func(w http.ResponseWriter, r *http.Request) {
		if !authenticate(r, "app_user", "create") {
			writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
			return
		}
		if err := UserCreate(r.Context(), store, w, r); err != nil {
			slog.Warn("error in UserCreate", "err", err)
			writeError(w, http.StatusInternalServerError, err)
		}
	})
	mux.HandleFunc("GET /User/{id}", func(w http.ResponseWriter, r *http.Request) {
		if !authenticate(r, "app_user", "read") {
			writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
			return
		}
		if err := UserGet(r.Context(), store, w, r); err != nil {
			slog.Warn("error in UserGet", "err", err)
			writeError(w, http.StatusInternalServerError, err)
		}
	})
	mux.HandleFunc("POST /User", func(w http.ResponseWriter, r *http.Request) {
		if !authenticate(r, "app_user", "read") {
			writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
			return
		}
		if err := UserFind(r.Context(), store, w, r); err != nil {
			slog.Warn("error in UserFind", "err", err)
			writeError(w, http.StatusInternalServerError, err)
		}
	})
	mux.HandleFunc("PATCH /User/{id}", func(w http.ResponseWriter, r *http.Request) {
		if !authenticate(r, "app_user", "update") {
			writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
			return
		}
		if err := UserUpdate(r.Context(), store, w, r); err != nil {
			slog.Warn("error in UserUpdate", "err", err)
			writeError(w, http.StatusInternalServerError, err)
		}
	})
	mux.HandleFunc("DELETE /User/{id}", func(w http.ResponseWriter, r *http.Request) {
		if !authenticate(r, "app_user", "delete") {
			writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
			return
		}
		if err := UserDelete(r.Context(), store, w, r); err != nil {
			slog.Warn("error in UserDelete", "err", err)
			writeError(w, http.StatusInternalServerError, err)
		}
	})
}

func UserCreate(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
	var obj model.User
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		slog.Warn("invalid body", "err", err)
		return fmt.Errorf("invalid body")
	}
	if user, ok := ctx.Value(HandlerCtxKeyUser).(*LoginUser); ok && user.User != nil {
		obj.CreatedBy = user.User
	} else {
		return fmt.Errorf("missing user in context")
	}
	obj.CreatedAt = time.Now()
	if user, ok := ctx.Value(HandlerCtxKeyUser).(*LoginUser); ok && user.User != nil {
		obj.UpdatedBy = user.User
	} else {
		return fmt.Errorf("missing user in context")
	}
	obj.UpdatedAt = time.Now()

	res, err := store.User().Create(ctx, obj)
	if err != nil {
		slog.Warn("error create User", "obj", obj, "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(res)
}

func UserGet(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
	pid := r.PathValue("id")
	id, err := strconv.ParseInt(pid, 10, 64)
	if err != nil {
		slog.Warn("invalid id", "id", pid, "err", err)
		return fmt.Errorf("invalid id")
	}
	obj, err := store.User().Get(ctx, id)
	if err != nil {
		slog.Warn("error get User", "id", id, "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(obj)
}

func UserFind(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
	var obj struct {
		Limit   int                 `json:"limit"`
		Offset  int64               `json:"offset"`
		Filter  []model.UserFilter  `json:"filter"`
		Sorting []model.UserSorting `json:"sorting"`
	}
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		slog.Warn("invalid body", "err", err)
		return fmt.Errorf("invalid body")
	}
	var result struct {
		List  []model.User `json:"list"`
		Total int64        `json:"total"`
	}
	result.List, result.Total, err = store.User().Find(ctx, obj.Filter, obj.Sorting, obj.Limit, obj.Offset)
	if err != nil {
		slog.Warn("error find User", "filter", obj.Filter, "sorting", obj.Sorting, "limit", obj.Limit, "offset", obj.Offset, "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(result)
}

func UserUpdate(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
	var obj struct {
		Value  model.User        `json:"value"`
		Fields []model.UserField `json:"fields"`
	}
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		slog.Warn("invalid body", "err", err)
		return fmt.Errorf("invalid body")
	}
	if user, ok := ctx.Value(HandlerCtxKeyUser).(*LoginUser); ok && user.User != nil {
		obj.Value.UpdatedBy = user.User
		obj.Fields = append(obj.Fields, model.UserField_UpdatedBy)
	} else {
		return fmt.Errorf("missing user in context")
	}
	obj.Value.UpdatedAt = time.Now()
	obj.Fields = append(obj.Fields, model.UserField_UpdatedAt)

	pid := r.PathValue("id")
	id, err := strconv.ParseInt(pid, 10, 64)
	if err != nil {
		slog.Warn("invalid id", "id", pid, "err", err)
		return fmt.Errorf("invalid id")
	}
	obj.Value.ID = id
	err = store.User().Update(ctx, obj.Value, obj.Fields)
	if err != nil {
		slog.Warn("error update User", "obj", obj, "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(obj.Value)
}

func UserDelete(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
	pid := r.PathValue("id")
	id, err := strconv.ParseInt(pid, 10, 64)
	if err != nil {
		slog.Warn("invalid id", "id", pid, "err", err)
		return fmt.Errorf("invalid id")
	}
	err = store.User().Delete(ctx, id)
	if err != nil {
		slog.Warn("error get User", "id", id, "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}
