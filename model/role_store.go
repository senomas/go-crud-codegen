// Code generated by apigen. DO NOT EDIT.
// GENERATED: 2025-10-06T13:29:15+07:00

package model

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log/slog"
	"strings"
)

func (r *StoreImpl) Role() RoleStore {
	return &RoleStoreImpl{
		StoreImpl: r,
	}
}

type RoleStore interface {
	Create(ctx context.Context, obj Role) (*Role, error)
	Get(ctx context.Context, id int64) (*Role, error)
	GetByName(ctx context.Context, name string) (*Role, error)
	FindOne(ctx context.Context, filter []RoleFilter, sorting []RoleSorting) (*Role, error)
	Find(ctx context.Context, filter []RoleFilter, sorting []RoleSorting, limit int, offset int64) ([]Role, int64, error)
	Update(ctx context.Context, obj Role, fields []RoleField) error
	Delete(ctx context.Context, id int64) error
}

type RoleStoreImpl struct {
	*StoreImpl
}

func (r *RoleStoreImpl) Create(ctx context.Context, obj Role) (*Role, error) {
	var tx *sql.Tx
	var err error
	var txNew bool
	tx, err = r.db.BeginTx(ctx, nil)
	txNew = true
	defer tx.Rollback()
	qry := `
    INSERT INTO app_role (
      name,
      description,
      privileges
    ) VALUES (
      $1,
      $2,
      $3
    )`
	slog.Debug("RoleCreate",
		slog.String("qry", qry),
		slog.String("name", obj.Name),
		logNullString("description", obj.Description),
		slog.String("privileges", obj.Privileges),
	)
	res, err := tx.ExecContext(ctx, qry,
		obj.Name,
		obj.Description,
		obj.Privileges,
	)
	if err != nil {
		slog.Error("Insert", "qry:", qry, "Error:", err)
		return nil, err
	}
	ra, err := res.RowsAffected()
	if err != nil {
		return nil, err
	}
	if ra != 1 {
		return nil, fmt.Errorf("ERR_INSERT_FAILED")
	}
	obj.ID, err = res.LastInsertId()
	if err != nil {
		return nil, err
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return nil, err
		}
	}
	return &obj, nil
}

func (r *RoleStoreImpl) Get(ctx context.Context, id int64) (*Role, error) {
	qry := `
    SELECT
      obj.id,
      obj.name,
      obj.description,
      obj.privileges
    FROM
      app_role obj
    WHERE
      obj.id = $1`
	var obj Role

	slog.Debug("Role.Get", slog.String("qry", qry), slog.Int64("id", id))
	rows, err := r.db.QueryContext(ctx, qry, id)
	if err != nil {
		slog.Error("Query", "qry", qry, "Error", err)
		return nil, err
	}
	if rows.Next() {
		err = rows.Scan(
			&obj.ID,
			&obj.Name,
			&obj.Description,
			&obj.Privileges,
		)
		if err != nil {
			return nil, err
		}
		for rows.Next() {
			err = rows.Scan(
				&obj.ID,
				&obj.Name,
				&obj.Description,
				&obj.Privileges,
			)
			if err != nil {
				return nil, err
			}
		}
	}
	return &obj, nil
}

func (r *RoleStoreImpl) GetByName(ctx context.Context, name string) (*Role, error) {
	qry := `
    SELECT
      obj.id,
      obj.name,
      obj.description,
      obj.privileges
    FROM
      app_role obj
    WHERE
      obj.name = $1`
	var obj Role

	slog.Debug("Name.Get", slog.String("qry", qry), slog.String("name", name))
	rows, err := r.db.QueryContext(ctx, qry, name)
	if err != nil {
		return nil, err
	}
	for rows.Next() {
		err = rows.Scan(
			&obj.ID,
			&obj.Name,
			&obj.Description,
			&obj.Privileges,
		)
		if err != nil {
			return nil, err
		}
	}
	return &obj, nil
}

func (r *RoleStoreImpl) FindOne(ctx context.Context, filter []RoleFilter, sorting []RoleSorting) (*Role, error) {
	qfilter := []string{}
	args := []any{}
	for _, f := range filter {
		switch f.Field {
		case RoleField_Name:
			switch f.Op {
			case FilterOp_EQ:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name = $%d", len(args)))
			case FilterOp_Like:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name LIKE $%d", len(args)))
			case FilterOp_ILike:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name ILIKE $%d", len(args)))
			default:
				return nil, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		case RoleField_Description:
			switch f.Op {
			case FilterOp_EQ:
				var val sql.NullString
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.description = $%d", len(args)))
			case FilterOp_Like:
				var val sql.NullString
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.description LIKE $%d", len(args)))
			case FilterOp_ILike:
				var val sql.NullString
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.description ILIKE $%d", len(args)))
			default:
				return nil, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		default:
			return nil, fmt.Errorf("unsupported filter field %v", f.Field)
		}
	}
	qry := `
    SELECT
      obj.id,
      obj.name,
      obj.description,
      obj.privileges
    FROM
      app_role obj`
	if len(qfilter) > 0 {
		qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
	}
	if len(sorting) > 0 {
		sorts := []string{}
		for _, f := range sorting {
			switch f.Field {
			case RoleField_Name:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.name ASC")
				} else {
					sorts = append(sorts, "obj.name DESC")
				}
			case RoleField_Description:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.description ASC")
				} else {
					sorts = append(sorts, "obj.description DESC")
				}
			}
		}
		if len(sorts) > 0 {
			qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
		}
	}
	qry += "\n  LIMIT 1"
	slog.Debug("FindOne", "qry", qry, "args", args)
	rows, err := r.db.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Query list", "qry:", qry, "Error:", err)
		return nil, err
	}
	if rows.Next() {
		var obj Role

		err = rows.Scan(
			&obj.ID,
			&obj.Name,
			&obj.Description,
			&obj.Privileges,
		)
		if err != nil {
			return nil, err
		}
		return &obj, nil
	}
	return nil, fmt.Errorf("not found")
}

func (r *RoleStoreImpl) Find(ctx context.Context, filter []RoleFilter, sorting []RoleSorting, limit int, offset int64) ([]Role, int64, error) {
	qfilter := []string{}
	args := []any{}
	for _, f := range filter {
		switch f.Field {
		case RoleField_Name:
			switch f.Op {
			case FilterOp_EQ:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name = $%d", len(args)))
			case FilterOp_Like:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name LIKE $%d", len(args)))
			case FilterOp_ILike:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name ILIKE $%d", len(args)))
			default:
				return nil, 0, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		case RoleField_Description:
			switch f.Op {
			case FilterOp_EQ:
				var val sql.NullString
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.description = $%d", len(args)))
			case FilterOp_Like:
				var val sql.NullString
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.description LIKE $%d", len(args)))
			case FilterOp_ILike:
				var val sql.NullString
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.description ILIKE $%d", len(args)))
			default:
				return nil, 0, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		default:
			return nil, 0, fmt.Errorf("unsupported filter field %v", f.Field)
		}
	}
	qry := `SELECT COUNT(obj.id) FROM app_role obj`
	if len(qfilter) > 0 {
		qry += " WHERE " + strings.Join(qfilter, " AND ")
	}
	total := int64(0)
	err := r.db.QueryRowContext(ctx, qry, args...).Scan(&total)
	if err != nil {
		slog.Error("Query count", "qry:", qry, "Error:", err)
		return nil, 0, err
	}
	qry = `SELECT
      obj.id,
      obj.name,
      obj.description,
      obj.privileges
    FROM
      app_role obj`
	if len(qfilter) > 0 {
		qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
	}
	if len(sorting) > 0 {
		sorts := []string{}
		for _, f := range sorting {
			switch f.Field {
			case RoleField_ID:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.id ASC")
				} else {
					sorts = append(sorts, "obj.id DESC")
				}
			case RoleField_Name:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.name ASC")
				} else {
					sorts = append(sorts, "obj.name DESC")
				}
			case RoleField_Description:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.description ASC")
				} else {
					sorts = append(sorts, "obj.description DESC")
				}

			default:
				return nil, 0, fmt.Errorf("field %v is unsorted", f)
			}
		}
		if len(sorts) > 0 {
			qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
		}
	}
	qry += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
	slog.Debug("Find", "qry", qry, "args", args)
	rows, err := r.db.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Query list", "qry:", qry, "Error:", err)
		return nil, 0, err
	}
	list := []Role{}
	for rows.Next() {
		var obj Role

		err = rows.Scan(
			&obj.ID,
			&obj.Name,
			&obj.Description,
			&obj.Privileges,
		)
		if err != nil {
			return nil, total, err
		}
		list = append(list, obj)
	}
	return list, total, nil
}

func (r *RoleStoreImpl) Update(ctx context.Context, obj Role, fields []RoleField) error {
	var tx *sql.Tx
	var err error
	var txNew bool
	tx, err = r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	txNew = true
	defer tx.Rollback()
	args := []any{}
	qry := `UPDATE app_role SET`
	for _, f := range fields {
		switch f {
		case RoleField_Name:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Name)
			qry += fmt.Sprintf("  name = $%d", len(args))
		case RoleField_Description:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Description)
			qry += fmt.Sprintf("  description = $%d", len(args))
		case RoleField_Privileges:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Privileges)
			qry += fmt.Sprintf("  privileges = $%d", len(args))
		default:
			return fmt.Errorf("field %v is unknown", f)
		}
	}
	qry += "\nWHERE\n"
	args = append(args, obj.ID)
	qry += fmt.Sprintf("  id = $%d", len(args))

	slog.Debug("Role.Update",
		slog.String("qry", qry),
		slog.Group("args", args...),
	)
	res, err := tx.ExecContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Update", "qry:", qry, "Error:", err)
		return err
	}
	ra, err := res.RowsAffected()
	if err != nil {
		slog.Error("Update", "qry:", qry, "args:", args, "Error:", err)
		return err
	}
	if ra == 0 {
		return fmt.Errorf("no rows affected")
	}
	if ra != 1 {
		return fmt.Errorf("invalid rows affected (%d)", ra)
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *RoleStoreImpl) Delete(ctx context.Context, id int64) error {
	var tx *sql.Tx
	var err error
	var txNew bool
	tx, err = r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	txNew = true
	qry := `
    DELETE FROM app_role WHERE
      obj.id = $1`
	slog.Debug("Role.Delete", "qry", qry, "id", id)
	res, err := tx.ExecContext(ctx, qry, id)
	if err != nil {
		return err
	}
	ra, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if ra == 0 {
		return fmt.Errorf("no rows affected")
	}
	if ra != 1 {
		return fmt.Errorf("invalid rows affected (%d)", ra)
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return err
		}
	}
	return nil
}
