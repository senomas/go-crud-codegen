// Code generated by apigen. DO NOT EDIT.
// GENERATED: 2025-10-06T13:42:54+07:00

package model

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log/slog"
	"strings"
)

func (r *StoreImpl) User() UserStore {
	return &UserStoreImpl{
		StoreImpl: r,
	}
}

type UserStore interface {
	Create(ctx context.Context, obj User) (*User, error)
	Get(ctx context.Context, id int64) (*User, error)
	GetByEmail(ctx context.Context, email string) (*User, error)
	FindOne(ctx context.Context, filter []UserFilter, sorting []UserSorting) (*User, error)
	Find(ctx context.Context, filter []UserFilter, sorting []UserSorting, limit int, offset int64) ([]User, int64, error)
	Update(ctx context.Context, obj User, fields []UserField) error
	UpdatePassword(ctx context.Context, id int64, version int64, value string) error
	Delete(ctx context.Context, id int64) error
}

type UserStoreImpl struct {
	*StoreImpl
}

func (r *UserStoreImpl) Create(ctx context.Context, obj User) (*User, error) {
	var tx *sql.Tx
	var err error
	var txNew bool
	tx, err = r.db.BeginTx(ctx, nil)
	txNew = true
	defer tx.Rollback()
	obj.Version = 1
	obj_Password, err := HashPassword(obj.Password)
	if err != nil {
		return nil, err
	}
	var objCreatedBy_ID sql.NullInt64
	if obj.CreatedBy != nil {
		objCreatedBy_ID = sql.NullInt64{Int64: obj.CreatedBy.ID, Valid: true}
	} else {
		objCreatedBy_ID = sql.NullInt64{Valid: false}
	}
	var objUpdatedBy_ID sql.NullInt64
	if obj.UpdatedBy != nil {
		objUpdatedBy_ID = sql.NullInt64{Int64: obj.UpdatedBy.ID, Valid: true}
	} else {
		objUpdatedBy_ID = sql.NullInt64{Valid: false}
	}
	qry := `
    INSERT INTO app_user (
      email,
      version,
      name,
      password,
      token,
      created_by,
      created_at,
      updated_by,
      updated_at
    ) VALUES (
      $1,
      $2,
      $3,
      $4,
      $5,
      $6,
      $7,
      $8,
      $9
    )`
	slog.Debug("UserCreate",
		slog.String("qry", qry),
		slog.String("email", obj.Email),
		slog.Int64("version", obj.Version),
		slog.String("name", obj.Name),
		slog.String("password", obj.Password),
		logNullString("token", obj.Token),
		logNullInt64("CreatedBy.id", objCreatedBy_ID),
		slog.Time("created_at", obj.CreatedAt),
		logNullInt64("UpdatedBy.id", objUpdatedBy_ID),
		slog.Time("updated_at", obj.UpdatedAt),
	)
	res, err := tx.ExecContext(ctx, qry,
		obj.Email,
		obj.Version,
		obj.Name,
		obj_Password,
		obj.Token,
		objCreatedBy_ID,
		obj.CreatedAt,
		objUpdatedBy_ID,
		obj.UpdatedAt,
	)
	if err != nil {
		slog.Error("Insert", "qry:", qry, "Error:", err)
		return nil, err
	}
	ra, err := res.RowsAffected()
	if err != nil {
		return nil, err
	}
	if ra != 1 {
		return nil, fmt.Errorf("ERR_INSERT_FAILED")
	}
	obj.ID, err = res.LastInsertId()
	if err != nil {
		return nil, err
	}
	qry = `
    INSERT INTO app_user_role (app_user, app_role)
    VALUES (
        $1, 
        $2)`
	for _, objRef := range obj.Roles {
		res, err := tx.ExecContext(ctx, qry, obj.ID, objRef.ID)
		if err != nil {
			slog.Error("Insert app_user_role", "qry:", qry, "Error:", err)
			return nil, err
		}
		ra, err := res.RowsAffected()
		if err != nil {
			return nil, err
		}
		if ra != 1 {
			return nil, fmt.Errorf("ERR_INSERT_FAILED")
		}
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return nil, err
		}
	}
	return &obj, nil
}

func (r *UserStoreImpl) Get(ctx context.Context, id int64) (*User, error) {
	qry := `
    SELECT
      obj.id,
      obj.email,
      obj.version,
      obj.name,
      obj.password,
      obj.token,
      objRoles_ref.id,
      objRoles_ref.name,
      objRoles_ref.privileges,
      objCreatedBy.id,
      objCreatedBy.name,
      objCreatedBy.email,
      obj.created_at,
      objUpdatedBy.id,
      objUpdatedBy.name,
      objUpdatedBy.email,
      obj.updated_at
    FROM
      ((((app_user obj LEFT JOIN app_user_role objRoles ON obj.id = objRoles.app_user)
      LEFT JOIN app_role objRoles_ref ON objRoles_ref.id = objRoles.app_role)
      LEFT JOIN app_user objCreatedBy ON obj.created_by = objCreatedBy.id)
      LEFT JOIN app_user objUpdatedBy ON obj.updated_by = objUpdatedBy.id)
    WHERE
      obj.id = $1`
	var obj User
	var refRoles *Role
	var refRoles_ID sql.NullInt64
	var refRoles_Name sql.NullString
	var refRoles_Privileges sql.NullString
	var refCreatedBy_ID sql.NullInt64
	var refCreatedBy_Name sql.NullString
	var refCreatedBy_Email sql.NullString
	var refUpdatedBy_ID sql.NullInt64
	var refUpdatedBy_Name sql.NullString
	var refUpdatedBy_Email sql.NullString
	slog.Debug("User.Get", slog.String("qry", qry), slog.Int64("id", id))
	rows, err := r.db.QueryContext(ctx, qry, id)
	if err != nil {
		slog.Error("Query", "qry", qry, "Error", err)
		return nil, err
	}
	if rows.Next() {
		err = rows.Scan(
			&obj.ID,
			&obj.Email,
			&obj.Version,
			&obj.Name,
			&obj.Password,
			&obj.Token,
			&refRoles_ID,
			&refRoles_Name,
			&refRoles_Privileges,
			&refCreatedBy_ID,
			&refCreatedBy_Name,
			&refCreatedBy_Email,
			&obj.CreatedAt,
			&refUpdatedBy_ID,
			&refUpdatedBy_Name,
			&refUpdatedBy_Email,
			&obj.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		if refCreatedBy_ID.Valid {
			if obj.CreatedBy == nil {
				obj.CreatedBy = &User{ID: refCreatedBy_ID.Int64}
			} else {
				obj.CreatedBy.ID = refCreatedBy_ID.Int64
			}
		}
		if refCreatedBy_Name.Valid {
			obj.CreatedBy.Name = refCreatedBy_Name.String
		}
		if refCreatedBy_Email.Valid {
			obj.CreatedBy.Email = refCreatedBy_Email.String
		}
		if refUpdatedBy_ID.Valid {
			if obj.UpdatedBy == nil {
				obj.UpdatedBy = &User{ID: refUpdatedBy_ID.Int64}
			} else {
				obj.UpdatedBy.ID = refUpdatedBy_ID.Int64
			}
		}
		if refUpdatedBy_Name.Valid {
			obj.UpdatedBy.Name = refUpdatedBy_Name.String
		}
		if refUpdatedBy_Email.Valid {
			obj.UpdatedBy.Email = refUpdatedBy_Email.String
		}

		if refRoles_ID.Valid {
			refRoles = &Role{ID: refRoles_ID.Int64}
		}
		if refRoles != nil && refRoles_Name.Valid {
			refRoles.Name = refRoles_Name.String
		}
		if refRoles != nil && refRoles_Privileges.Valid {
			refRoles.Privileges = refRoles_Privileges.String
		}
		if refRoles != nil {
			obj.Roles = append(obj.Roles, *refRoles)
			refRoles = nil
		}
		for rows.Next() {
			err = rows.Scan(
				&obj.ID,
				&obj.Email,
				&obj.Version,
				&obj.Name,
				&obj.Password,
				&obj.Token,
				&refRoles_ID,
				&refRoles_Name,
				&refRoles_Privileges,
				&refCreatedBy_ID,
				&refCreatedBy_Name,
				&refCreatedBy_Email,
				&obj.CreatedAt,
				&refUpdatedBy_ID,
				&refUpdatedBy_Name,
				&refUpdatedBy_Email,
				&obj.UpdatedAt,
			)
			if err != nil {
				return nil, err
			}

			if refRoles_ID.Valid {
				refRoles = &Role{ID: refRoles_ID.Int64}
			}
			if refRoles != nil && refRoles_Name.Valid {
				refRoles.Name = refRoles_Name.String
			}
			if refRoles != nil && refRoles_Privileges.Valid {
				refRoles.Privileges = refRoles_Privileges.String
			}
			if refRoles != nil {
				obj.Roles = append(obj.Roles, *refRoles)
				refRoles = nil
			}
		}
	}
	return &obj, nil
}

func (r *UserStoreImpl) GetByEmail(ctx context.Context, email string) (*User, error) {
	qry := `
    SELECT
      obj.id,
      obj.email,
      obj.version,
      obj.name,
      obj.password,
      obj.token,
      objRoles_ref.id,
      objRoles_ref.name,
      objRoles_ref.privileges,
      objCreatedBy.id,
      objCreatedBy.name,
      objCreatedBy.email,
      obj.created_at,
      objUpdatedBy.id,
      objUpdatedBy.name,
      objUpdatedBy.email,
      obj.updated_at
    FROM
      ((((app_user obj LEFT JOIN app_user_role objRoles ON obj.id = objRoles.app_user)
      LEFT JOIN app_role objRoles_ref ON objRoles_ref.id = objRoles.app_role)
      LEFT JOIN app_user objCreatedBy ON obj.created_by = objCreatedBy.id)
      LEFT JOIN app_user objUpdatedBy ON obj.updated_by = objUpdatedBy.id)
    WHERE
      obj.email = $1`
	var obj User
	var refRoles *Role
	var refRoles_ID sql.NullInt64
	var refRoles_Name sql.NullString
	var refRoles_Privileges sql.NullString
	var refCreatedBy_ID sql.NullInt64
	var refCreatedBy_Name sql.NullString
	var refCreatedBy_Email sql.NullString
	var refUpdatedBy_ID sql.NullInt64
	var refUpdatedBy_Name sql.NullString
	var refUpdatedBy_Email sql.NullString
	slog.Debug("Email.Get", slog.String("qry", qry), slog.String("email", email))
	rows, err := r.db.QueryContext(ctx, qry, email)
	if err != nil {
		return nil, err
	}
	if refCreatedBy_ID.Valid {
		if obj.CreatedBy == nil {
			obj.CreatedBy = &User{ID: refCreatedBy_ID.Int64}
		} else {
			obj.CreatedBy.ID = refCreatedBy_ID.Int64
		}
	}
	if refCreatedBy_Name.Valid {
		obj.CreatedBy.Name = refCreatedBy_Name.String
	}
	if refCreatedBy_Email.Valid {
		obj.CreatedBy.Email = refCreatedBy_Email.String
	}
	if refUpdatedBy_ID.Valid {
		if obj.UpdatedBy == nil {
			obj.UpdatedBy = &User{ID: refUpdatedBy_ID.Int64}
		} else {
			obj.UpdatedBy.ID = refUpdatedBy_ID.Int64
		}
	}
	if refUpdatedBy_Name.Valid {
		obj.UpdatedBy.Name = refUpdatedBy_Name.String
	}
	if refUpdatedBy_Email.Valid {
		obj.UpdatedBy.Email = refUpdatedBy_Email.String
	}

	if refRoles_ID.Valid {
		refRoles = &Role{ID: refRoles_ID.Int64}
	}
	if refRoles != nil && refRoles_Name.Valid {
		refRoles.Name = refRoles_Name.String
	}
	if refRoles != nil && refRoles_Privileges.Valid {
		refRoles.Privileges = refRoles_Privileges.String
	}
	if refRoles != nil {
		obj.Roles = append(obj.Roles, *refRoles)
		refRoles = nil
	}
	for rows.Next() {
		err = rows.Scan(
			&obj.ID,
			&obj.Email,
			&obj.Version,
			&obj.Name,
			&obj.Password,
			&obj.Token,
			&refRoles_ID,
			&refRoles_Name,
			&refRoles_Privileges,
			&refCreatedBy_ID,
			&refCreatedBy_Name,
			&refCreatedBy_Email,
			&obj.CreatedAt,
			&refUpdatedBy_ID,
			&refUpdatedBy_Name,
			&refUpdatedBy_Email,
			&obj.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		if refRoles_ID.Valid {
			refRoles = &Role{ID: refRoles_ID.Int64}
		}
		if refRoles != nil && refRoles_Name.Valid {
			refRoles.Name = refRoles_Name.String
		}
		if refRoles != nil && refRoles_Privileges.Valid {
			refRoles.Privileges = refRoles_Privileges.String
		}
		if refRoles != nil {
			obj.Roles = append(obj.Roles, *refRoles)
			refRoles = nil
		}
	}
	return &obj, nil
}

func (r *UserStoreImpl) FindOne(ctx context.Context, filter []UserFilter, sorting []UserSorting) (*User, error) {
	qfilter := []string{}
	args := []any{}
	for _, f := range filter {
		switch f.Field {
		case UserField_Email:
			switch f.Op {
			case FilterOp_EQ:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.email = $%d", len(args)))
			case FilterOp_Like:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.email LIKE $%d", len(args)))
			case FilterOp_ILike:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.email ILIKE $%d", len(args)))
			default:
				return nil, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		case UserField_Name:
			switch f.Op {
			case FilterOp_EQ:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name = $%d", len(args)))
			case FilterOp_Like:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name LIKE $%d", len(args)))
			case FilterOp_ILike:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name ILIKE $%d", len(args)))
			default:
				return nil, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		default:
			return nil, fmt.Errorf("unsupported filter field %v", f.Field)
		}
	}
	qry := `
    SELECT
      obj.id,
      obj.email,
      obj.version,
      obj.name,
      obj.password,
      obj.token,
      objCreatedBy.id,
      objCreatedBy.name,
      objCreatedBy.email,
      obj.created_at,
      objUpdatedBy.id,
      objUpdatedBy.name,
      objUpdatedBy.email,
      obj.updated_at
    FROM
      ((app_user obj LEFT JOIN app_user objCreatedBy ON obj.created_by = objCreatedBy.id)
      LEFT JOIN app_user objUpdatedBy ON obj.updated_by = objUpdatedBy.id)`
	if len(qfilter) > 0 {
		qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
	}
	if len(sorting) > 0 {
		sorts := []string{}
		for _, f := range sorting {
			switch f.Field {
			case UserField_Email:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.email ASC")
				} else {
					sorts = append(sorts, "obj.email DESC")
				}
			case UserField_Name:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.name ASC")
				} else {
					sorts = append(sorts, "obj.name DESC")
				}
			}
		}
		if len(sorts) > 0 {
			qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
		}
	}
	qry += "\n  LIMIT 1"
	slog.Debug("FindOne", "qry", qry, "args", args)
	rows, err := r.db.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Query list", "qry:", qry, "Error:", err)
		return nil, err
	}
	if rows.Next() {
		var obj User
		var refCreatedBy_ID sql.NullInt64
		var refCreatedBy_Name sql.NullString
		var refCreatedBy_Email sql.NullString
		var refUpdatedBy_ID sql.NullInt64
		var refUpdatedBy_Name sql.NullString
		var refUpdatedBy_Email sql.NullString
		err = rows.Scan(
			&obj.ID,
			&obj.Email,
			&obj.Version,
			&obj.Name,
			&obj.Password,
			&obj.Token,
			&refCreatedBy_ID,
			&refCreatedBy_Name,
			&refCreatedBy_Email,
			&obj.CreatedAt,
			&refUpdatedBy_ID,
			&refUpdatedBy_Name,
			&refUpdatedBy_Email,
			&obj.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		if refCreatedBy_ID.Valid {
			if obj.CreatedBy == nil {
				obj.CreatedBy = &User{ID: refCreatedBy_ID.Int64}
			} else {
				obj.CreatedBy.ID = refCreatedBy_ID.Int64
			}
		}
		if refCreatedBy_Name.Valid {
			obj.CreatedBy.Name = refCreatedBy_Name.String
		}
		if refCreatedBy_Email.Valid {
			obj.CreatedBy.Email = refCreatedBy_Email.String
		}
		if refUpdatedBy_ID.Valid {
			if obj.UpdatedBy == nil {
				obj.UpdatedBy = &User{ID: refUpdatedBy_ID.Int64}
			} else {
				obj.UpdatedBy.ID = refUpdatedBy_ID.Int64
			}
		}
		if refUpdatedBy_Name.Valid {
			obj.UpdatedBy.Name = refUpdatedBy_Name.String
		}
		if refUpdatedBy_Email.Valid {
			obj.UpdatedBy.Email = refUpdatedBy_Email.String
		}
		return &obj, nil
	}
	return nil, fmt.Errorf("not found")
}

func (r *UserStoreImpl) Find(ctx context.Context, filter []UserFilter, sorting []UserSorting, limit int, offset int64) ([]User, int64, error) {
	qfilter := []string{}
	args := []any{}
	for _, f := range filter {
		switch f.Field {
		case UserField_Email:
			switch f.Op {
			case FilterOp_EQ:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.email = $%d", len(args)))
			case FilterOp_Like:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.email LIKE $%d", len(args)))
			case FilterOp_ILike:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.email ILIKE $%d", len(args)))
			default:
				return nil, 0, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		case UserField_Name:
			switch f.Op {
			case FilterOp_EQ:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name = $%d", len(args)))
			case FilterOp_Like:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name LIKE $%d", len(args)))
			case FilterOp_ILike:
				var val string
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
					return nil, 0, err
				}
				args = append(args, val)
				qfilter = append(qfilter, fmt.Sprintf("obj.name ILIKE $%d", len(args)))
			default:
				return nil, 0, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		default:
			return nil, 0, fmt.Errorf("unsupported filter field %v", f.Field)
		}
	}
	qry := `SELECT COUNT(obj.id) FROM app_user obj`
	if len(qfilter) > 0 {
		qry += " WHERE " + strings.Join(qfilter, " AND ")
	}
	total := int64(0)
	err := r.db.QueryRowContext(ctx, qry, args...).Scan(&total)
	if err != nil {
		slog.Error("Query count", "qry:", qry, "Error:", err)
		return nil, 0, err
	}
	qry = `SELECT
      obj.id,
      obj.email,
      obj.version,
      obj.name,
      obj.password,
      obj.token,
      objCreatedBy.id,
      objCreatedBy.name,
      objCreatedBy.email,
      obj.created_at,
      objUpdatedBy.id,
      objUpdatedBy.name,
      objUpdatedBy.email,
      obj.updated_at
    FROM
      ((app_user obj LEFT JOIN app_user objCreatedBy ON obj.created_by = objCreatedBy.id)
      LEFT JOIN app_user objUpdatedBy ON obj.updated_by = objUpdatedBy.id)`
	if len(qfilter) > 0 {
		qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
	}
	if len(sorting) > 0 {
		sorts := []string{}
		for _, f := range sorting {
			switch f.Field {
			case UserField_ID:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.id ASC")
				} else {
					sorts = append(sorts, "obj.id DESC")
				}
			case UserField_Email:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.email ASC")
				} else {
					sorts = append(sorts, "obj.email DESC")
				}
			case UserField_Name:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "obj.name ASC")
				} else {
					sorts = append(sorts, "obj.name DESC")
				}

			default:
				return nil, 0, fmt.Errorf("field %v is unsorted", f)
			}
		}
		if len(sorts) > 0 {
			qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
		}
	}
	qry += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
	slog.Debug("Find", "qry", qry, "args", args)
	rows, err := r.db.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Query list", "qry:", qry, "Error:", err)
		return nil, 0, err
	}
	list := []User{}
	for rows.Next() {
		var obj User
		var refCreatedBy_ID sql.NullInt64
		var refCreatedBy_Name sql.NullString
		var refCreatedBy_Email sql.NullString
		var refUpdatedBy_ID sql.NullInt64
		var refUpdatedBy_Name sql.NullString
		var refUpdatedBy_Email sql.NullString
		err = rows.Scan(
			&obj.ID,
			&obj.Email,
			&obj.Version,
			&obj.Name,
			&obj.Password,
			&obj.Token,
			&refCreatedBy_ID,
			&refCreatedBy_Name,
			&refCreatedBy_Email,
			&obj.CreatedAt,
			&refUpdatedBy_ID,
			&refUpdatedBy_Name,
			&refUpdatedBy_Email,
			&obj.UpdatedAt,
		)
		if err != nil {
			return nil, total, err
		}
		if refCreatedBy_ID.Valid {
			if obj.CreatedBy == nil {
				obj.CreatedBy = &User{ID: refCreatedBy_ID.Int64}
			} else {
				obj.CreatedBy.ID = refCreatedBy_ID.Int64
			}
		}
		if refCreatedBy_Name.Valid {
			obj.CreatedBy.Name = refCreatedBy_Name.String
		}
		if refCreatedBy_Email.Valid {
			obj.CreatedBy.Email = refCreatedBy_Email.String
		}
		if refUpdatedBy_ID.Valid {
			if obj.UpdatedBy == nil {
				obj.UpdatedBy = &User{ID: refUpdatedBy_ID.Int64}
			} else {
				obj.UpdatedBy.ID = refUpdatedBy_ID.Int64
			}
		}
		if refUpdatedBy_Name.Valid {
			obj.UpdatedBy.Name = refUpdatedBy_Name.String
		}
		if refUpdatedBy_Email.Valid {
			obj.UpdatedBy.Email = refUpdatedBy_Email.String
		}
		list = append(list, obj)
	}
	return list, total, nil
}

func (r *UserStoreImpl) Update(ctx context.Context, obj User, fields []UserField) error {
	var tx *sql.Tx
	var err error
	var txNew bool
	tx, err = r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	txNew = true
	defer tx.Rollback()
	args := []any{}
	qry := `UPDATE app_user SET`
	if len(args) > 0 {
		qry += ","
	}
	args = append(args, obj.Version+1)
	qry += fmt.Sprintf("  version = $%d", len(args))
	for _, f := range fields {
		switch f {
		case UserField_Email:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Email)
			qry += fmt.Sprintf("  email = $%d", len(args))
		case UserField_Name:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Name)
			qry += fmt.Sprintf("  name = $%d", len(args))
		case UserField_Token:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.Token)
			qry += fmt.Sprintf("  token = $%d", len(args))
		case UserField_Roles:
		case UserField_CreatedBy:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.CreatedBy.ID)
			qry += fmt.Sprintf("  created_by = $%d", len(args))
		case UserField_CreatedAt:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.CreatedAt)
			qry += fmt.Sprintf("  created_at = $%d", len(args))
		case UserField_UpdatedBy:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.UpdatedBy.ID)
			qry += fmt.Sprintf("  updated_by = $%d", len(args))
		case UserField_UpdatedAt:
			if len(args) > 0 {
				qry += ","
			}
			args = append(args, obj.UpdatedAt)
			qry += fmt.Sprintf("  updated_at = $%d", len(args))
		default:
			return fmt.Errorf("field %v is unknown", f)
		}
	}
	qry += "\nWHERE\n"
	args = append(args, obj.ID)
	qry += fmt.Sprintf("  id = $%d", len(args))
	args = append(args, obj.Version)
	qry += fmt.Sprintf(" AND\n  version = $%d", len(args))
	slog.Debug("User.Update",
		slog.String("qry", qry),
		slog.Group("args", args...),
	)
	res, err := tx.ExecContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Update", "qry:", qry, "Error:", err)
		return err
	}
	ra, err := res.RowsAffected()
	if err != nil {
		slog.Error("Update", "qry:", qry, "args:", args, "Error:", err)
		return err
	}
	if ra == 0 {
		return fmt.Errorf("no rows affected")
	}
	if ra != 1 {
		return fmt.Errorf("invalid rows affected (%d)", ra)
	}
	args = []any{}
	qry = `SELECT  app_role FROM app_user_role WHERE`
	qry += fmt.Sprintf(" app_user = $%d", len(args))
	args = append(args, obj.ID)
	rows, err := tx.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Query app_user_role", "qry:", qry, "Error:", err)
		return err
	}
	add_Roles := []*Role{}
	del_Roles := []*Role{}
	cur_Roles := []*Role{}
	for rows.Next() {
		var mobj Role
		err = rows.Scan(
			&mobj.ID,
		)
		if err != nil {
			slog.Error("Scan Role", "Error:", err)
			return err
		}
		cur_Roles = append(cur_Roles, &mobj)
	}
	for _, mobj := range obj.Roles {
		found := false
		for _, objRef := range cur_Roles {
			if objRef.ID == mobj.ID && true {
				found = true
				break
			}
		}
		if !found {
			add_Roles = append(add_Roles, &mobj)
		}
	}
	for _, mobj := range cur_Roles {
		found := false
		for _, objRef := range obj.Roles {
			if objRef.ID == mobj.ID && true {
				found = true
				break
			}
		}
		if !found {
			del_Roles = append(del_Roles, mobj)
		}
	}
	for _, mobj := range del_Roles {
		args = []any{}
		qry = `DELETE FROM app_user_role WHERE`
		qry += fmt.Sprintf(" app_user = $%d", len(args))
		args = append(args, obj.ID)
		qry += fmt.Sprintf(" AND app_role = $%d", len(args))
		args = append(args, mobj.ID)
		res, err := tx.ExecContext(ctx, qry, args...)
		if err != nil {
			slog.Error("Delete app_user_role", "qry:", qry, "Error:", err)
			return err
		}
		ra, err := res.RowsAffected()
		if err != nil {
			return err
		}
		if ra != 1 {
			return fmt.Errorf("ERR_DELETE_FAILED")
		}
	}
	for _, mobj := range add_Roles {
		args = []any{}
		qry = `INSERT INTO app_user_role (app_user, app_role)
      VALUES (
          $1, 
          $2)`
		args = append(args, obj.ID)
		args = append(args, mobj.ID)
		res, err := tx.ExecContext(ctx, qry, args...)
		if err != nil {
			slog.Error("Insert app_user_role", "qry:", qry, "Error:", err)
			return err
		}
		ra, err := res.RowsAffected()
		if err != nil {
			return err
		}
		if ra != 1 {
			return fmt.Errorf("ERR_INSERT_FAILED")
		}
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return err
		}
	}
	return nil
}
func (r *UserStoreImpl) UpdatePassword(ctx context.Context, id int64, version int64, value string) error {
	var tx *sql.Tx
	var err error
	var txNew bool
	tx, err = r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	txNew = true
	defer tx.Rollback()
	args := []any{}
	password, err := HashPassword(value)
	if err != nil {
		return err
	}
	qry := `UPDATE app_user SET `
	if len(args) > 0 {
		qry += ", "
	}
	args = append(args, password)
	qry += fmt.Sprintf("password = $%d", len(args))
	qry += ` WHERE `
	args = append(args, id)
	qry += fmt.Sprintf("  id = $%d", len(args))
	args = append(args, version)
	qry += fmt.Sprintf(" AND\n  version = $%d", len(args))
	slog.Debug("User.Password.Update",
		slog.String("qry", qry),
		slog.Group("args", args...),
	)
	res, err := tx.ExecContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Update", "qry:", qry, "Error:", err)
		return err
	}
	ra, err := res.RowsAffected()
	if err != nil {
		slog.Error("Update", "qry:", qry, "args:", args, "Error:", err)
		return err
	}
	if ra == 0 {
		return fmt.Errorf("no rows affected")
	}
	if ra != 1 {
		return fmt.Errorf("invalid rows affected (%d)", ra)
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *UserStoreImpl) Delete(ctx context.Context, id int64) error {
	var tx *sql.Tx
	var err error
	var txNew bool
	tx, err = r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	txNew = true
	qry := `
    DELETE FROM app_user WHERE
      obj.id = $1`
	slog.Debug("User.Delete", "qry", qry, "id", id)
	res, err := tx.ExecContext(ctx, qry, id)
	if err != nil {
		return err
	}
	ra, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if ra == 0 {
		return fmt.Errorf("no rows affected")
	}
	if ra != 1 {
		return fmt.Errorf("invalid rows affected (%d)", ra)
	}
	if txNew {
		err = tx.Commit()
		if err != nil {
			return err
		}
	}
	return nil
}
