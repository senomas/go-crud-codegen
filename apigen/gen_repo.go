package main

import (
	"fmt"
	"log"
	"os"
	"path"
	"strings"
)

func GenRepos(models map[string]ModelDef, dir string) error {
	for name, md := range models {
		if n, ok := strings.CutPrefix(md.Path, dir); ok {
			mdir := path.Join(dir, n, fmt.Sprintf("%s_repo.go", strings.ToLower(name)))
			f, err := os.Create(mdir)
			if err != nil {
				return err
			}
			defer f.Close()

			f.WriteString("\n// Code generated by apigen. DO NOT EDIT.\n\n")
			if n == "" {
				f.WriteString("package model;\n")
			} else {
				fmt.Fprintf(f, "package %s;\n", path.Base(n))
			}

			err = GenRepo(f, name, &md)
			if err != nil {
				return err
			}

			err = GenRepoCreate(f, name, &md)
			if err != nil {
				return err
			}

			err = GenRepoGet(f, name, &md)
			if err != nil {
				return err
			}

			fmt.Printf("Model: %s PATH [%s]\n", name, mdir)
		} else {
			log.Fatalf("Model %s path %s not in dir %s", name, md.Path, dir)
		}
	}
	return nil
}

func GenRepo(f *os.File, name string, md *ModelDef) error {
	_, err := fmt.Fprintf(f, "\ntype %sRepository interface {\n", name)
	if err != nil {
		return err
	}
	fk := []string{}
	for _, pk := range md.PKey {
		ok := false
		for _, fd := range md.Fields {
			if fd.ID == pk {
				fk = append(fk, fmt.Sprintf("%s %s", fd.Field, fd.GoType))
				ok = true
			}
		}
		if !ok {
			return fmt.Errorf("model %s pkey %s not found", name, pk)
		}
	}
	_, err = fmt.Fprintf(f, "  Create(obj %s) (*%s, error)\n", name, name)
	if err != nil {
		return err
	}
	_, err = fmt.Fprintf(f, "  Get(%s) (*%s, error)\n", strings.Join(fk, ", "), name)
	if err != nil {
		return err
	}
	_, err = fmt.Fprintf(f, "  Find(filter %sFilter, sort []%sSort) ([]%s, int64, error)\n", name, name, name)
	if err != nil {
		return err
	}
	_, err = fmt.Fprintf(f, "  Update(obj %s) error\n", name)
	if err != nil {
		return err
	}
	_, err = fmt.Fprintf(f, "  Delete(%s) error\n", strings.Join(fk, ", "))
	if err != nil {
		return err
	}
	_, err = fmt.Fprintf(f, "}\n")
	if err != nil {
		return err
	}

	_, err = fmt.Fprintf(f, "\ntype %sRepositoryImpl struct {\n  ctx context.Context\n  db  *sql.DB\n}\n", name)
	return err
}
