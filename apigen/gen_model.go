package main

import (
	"fmt"
	"log"
	"os"
	"path"
	"strings"
)

func GenModels(models map[string]ModelDef, dir string) error {
	for name, md := range models {
		if n, ok := strings.CutPrefix(md.Path, dir); ok {
			mdir := path.Join(dir, n, fmt.Sprintf("%s.go", strings.ToLower(name)))
			f, err := os.Create(mdir)
			if err != nil {
				return err
			}
			defer f.Close()

			f.WriteString("\n// Code generated by apigen. DO NOT EDIT.\n\n")
			if n == "" {
				f.WriteString("package model;\n")
			} else {
				fmt.Fprintf(f, "package %s;\n", path.Base(n))
			}

			err = GenModel(f, name, &md)
			if err != nil {
				return err
			}

			err = GenModelSort(f, name, &md)
			if err != nil {
				return err
			}

			err = GenModelFilter(f, name, &md)
			if err != nil {
				return err
			}

			fmt.Printf("Model: %s PATH [%s]\n", name, mdir)
		} else {
			log.Fatalf("Model %s path %s not in dir %s", name, md.Path, dir)
		}
	}
	return nil
}

func GenModel(f *os.File, name string, md *ModelDef) error {
	_, err := fmt.Fprintf(f, "\ntype %s struct {\n", name)
	if err != nil {
		return err
	}
	for _, fd := range md.Fields {
		ff := fd.Field
		if fd.Null {
			ff += ",omitempty"
		}
		_, err = fmt.Fprintf(f, "  %s %s `json:\"%s\"`\n", fd.ID, fd.GoType, ff)
		if err != nil {
			return err
		}
	}
	_, err = fmt.Fprintf(f, "}\n")
	return err
}

func GenModelSort(f *os.File, name string, md *ModelDef) error {
	_, err := fmt.Fprintf(f, "\ntype %sSortFields string\n", name)
	if err != nil {
		return err
	}

	_, err = fmt.Fprint(f, "\nconst (\n")
	if err != nil {
		return err
	}
	for _, fd := range md.Fields {
		if fd.Sorted == nil || *fd.Sorted {
			fmt.Fprintf(f, "  %s_%s %sSortFields = \"%s\"\n", name, fd.ID, name, fd.Field)
		}
	}
	_, err = fmt.Fprintf(f, ")\n\ntype %sSort struct {\n  Field %sSortFields `json:\"field\"`\n  Dir SortDir `json:\"dir\"`\n}\n", name, name)
	return err
}

func GenModelFilter(f *os.File, name string, md *ModelDef) error {
	_, err := fmt.Fprintf(f, "\ntype %sFilter struct {\n", name)
	if err != nil {
		return err
	}
	for _, fd := range md.Fields {
		if fd.Filter == nil || *fd.Filter {
			ft := ""
			switch fd.Type {
			case "text":
				ft = "StringFilter"
			case "autoincrement", "int":
				ft = "IntFilter"
			}
			if ft != "" {
				_, err = fmt.Fprintf(f, "  %s %s `json:\"%s\"`\n", fd.ID, ft, fd.Field)
			}
		}
		if err != nil {
			return err
		}
	}
	_, err = fmt.Fprint(f, "}\n")
	return err
}
