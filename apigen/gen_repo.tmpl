// Code generated by apigen. DO NOT EDIT.

package {{.Package}}

import (
	"log/slog"
)

type {{.Name}}Repository interface {
  Create(ctx context.Context, obj {{.Name}}) (*{{.Name}}, error)
  Get(ctx context.Context, id int64) (*{{.Name}}, error)
  Find(ctx context.Context, filter []{{.Name}}Filter, sort []{{.Name}}Sort, limit int, offset int64) ([]{{.Name}}, int64, error)
  Update(ctx context.Context, obj {{.Name}}) error
  Delete(ctx context.Context, id int64) error
}

type {{.Name}}RepositoryImpl struct {
	*RepositoryImpl
}

func (r *{{.Name}}RepositoryImpl) Create(ctx context.Context, obj {{.Name}}) (*{{.Name}}, error) {
  tx, err := r.db.BeginTx(ctx, nil)
  if err != nil {
    return nil, err
  }
  defer tx.Rollback()
  sql := `
    INSERT INTO {{.Table}} (
	  	{{ $idx := 0 }}{{- range .Fields }}{{if not (eq .Type "autoincrement") -}}
			{{if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}{{.Field}}
		  {{- end}}{{end}}
    ) VALUES (
			{{ $idx := 0 }}{{- range $i, $v := .Fields}}{{if not (eq .Type "autoincrement") -}}
			{{if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}${{$i}}
		  {{- end}}{{end}}
    )`
  res, err := r.db.ExecContext(ctx, sql,
		{{- range .Fields }}{{if not (eq .Type "autoincrement") }}
		obj.{{.Name}},
		{{- end}}{{end}}
  )
  if err != nil {
  	return nil, err
  }
  obj.ID, err = res.LastInsertId()
  if err != nil {
  	return nil, err
  }
  err = tx.Commit()
  if err != nil {
  	return nil, err
  }
  return &obj, nil
}

{{- define "SelectField" }}
	{{- range $idx, $v := . -}}
	{{if gt $idx 0}},{{ "\n      " }}{{end}}{{.Field}}
	{{- end}}
{{- end}}

{{- define "ScanField" }}
	{{- range . }}
		&obj.{{.Name}},
	{{- end}}
{{- end}}

{{- define "WhereFk" }}
  {{- range $i, $v := . -}}
	{{if gt $i 0}} AND{{ "\n      " }}{{end}}{{.Field}} = ${{add $i 1}}
  {{- end}}
{{- end}}

{{- define "ArgFk" }}
  {{- range $i, $v := . -}}
	{{if gt $i 0}}, {{end}}{{.Field}}
  {{- end}}
{{- end}}

func (r *{{.Name}}RepositoryImpl) Get(ctx context.Context, {{range .PKeys}}{{.Field}} {{.GoType}}{{if not .Last}}, {{end}}{{end}}) (*{{.Name}}, error) {
  sql := `
    SELECT
      {{ template "SelectField" .Fields }}
    FROM {{.Table}} WHERE
      {{ template "WhereFk" .PKeys }}`
  var obj {{.Name}};
  err := r.db.QueryRowContext(ctx, sql, {{ template "ArgFk" .PKeys}}).Scan(
    {{- template "ScanField" .Fields }}
	)
  if err != nil {
  	return nil, err
  }
  return &obj, nil
}

{{define "QueryFindCount" -}}
SELECT COUNT({{ range $i, $x := .PKeys -}}
	{{- if gt $i 0}},{{end}}{{.Field}}
	{{- end}}) FROM {{.Table}}
{{- end -}}

func (r *{{.Name}}RepositoryImpl) Find(ctx context.Context, filter []{{.Name}}Filter, sort []{{.Name}}Sort, limit int, offset int64) ([]{{.Name}}, int64, error) {
  qfilter := []string{}
  args := []any{}
  for _, f := range filter {
    switch f.Field {
		{{range .Fields }}{{if eq .Filter "text" -}}
		case {{.Model}}Field_{{.Name}}:
			switch f.Op {
			case FilterOp_EQ:
				args = append(args, f.Value)
			  qfilter = append(qfilter, "{{.Field}} = ?")
			case FilterOp_Like:
				args = append(args, f.Value)
			  qfilter = append(qfilter, fmt.Sprintf("{{.Field}} LIKE $%d", len(args)))
			case FilterOp_ILike:
				args = append(args, f.Value)
			  qfilter = append(qfilter, fmt.Sprintf("{{.Field}} ILIKE $%d", len(args)))
			default:
				return nil, 0, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
		  }
		{{end}}{{end}}}
  }
  sql := `{{template "QueryFindCount" .}}`
  if len(qfilter) > 0 {
    sql += " WHERE " + strings.Join(qfilter, " AND ")
  }
	slog.Info("Find", "SQL:", sql)
  total := int64(0)
  err := r.db.QueryRowContext(ctx, sql, args...).Scan(&total)
  if err != nil {
  	return nil, 0, err
  }
  sql = `
    SELECT
      {{ template "SelectField" .Fields }}
    FROM {{.Table}}`
  if len(qfilter) > 0 {
    sql += "\n  WHERE" + strings.Join(qfilter, " AND\n    ")
  }
	sql += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
  rows, err := r.db.QueryContext(ctx, sql, args...)
  if err != nil {
    return nil, 0, err
  }
  list := []{{.Name}}{};
  for rows.Next() {
    var obj {{.Name}};
  	err = rows.Scan(
      {{- template "ScanField" .Fields }}
		)
		list = append(list, obj)
	  if err != nil {
	  	return nil, total, err
	  }
  }
  return list, total, nil
}

func (r *{{.Name}}RepositoryImpl) Update(ctx context.Context, obj {{.Name}}) error {
  tx, err := r.db.BeginTx(ctx, nil)
  if err != nil {
    return err
  }
  defer tx.Rollback()
	sql := `{{ $i := 1 }}
    UPDATE {{.Table}} SET
  		{{ range $idx, $v := .Updatables -}}
			{{if gt $idx 0}},{{"\n      "}}{{end}}{{.Field}} = ${{$i}}{{$i = add $i 1}}
		  {{- end}}
    WHERE
  		{{- range $idx, $v := .PKeys }}
			{{if gt $idx 0}} AND{{"\n      "}}{{end}}{{.Field}} = ${{$i}}{{$i = add $i 1}}
		  {{- end}}`
  _, err = r.db.ExecContext(ctx, sql,
	  {{- range .Updatables }}
		obj.{{.Name}},
		{{- end}}
  	{{- range .PKeys }}
		obj.{{.Name}},
		{{- end}}
  )
  if err != nil {
  return err
  }
  err = tx.Commit()
  if err != nil {
  return err
  }
  return nil
}

func (r *{{.Name}}RepositoryImpl) Delete(ctx context.Context, {{range .PKeys}}{{.Field}} {{.GoType}}{{if not .Last}}, {{end}}{{end}}) error {
  sql := `
    DELETE FROM {{.Table}} WHERE
  		{{- range $i, $v := .PKeys }}
			{{.Field}} = ${{add $i 1}}{{if not .Last}} AND{{end}}
		  {{- end}}`
  _, err := r.db.ExecContext(ctx, sql, {{range .PKeys}}{{.Field}}{{if not .Last}}, {{end}}{{end}})
  if err != nil {
    return err
  }
  return nil
}
