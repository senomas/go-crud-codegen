// Code generated by apigen. DO NOT EDIT.

{{$Model := . -}}
package {{.Package}}

import (
  "log/slog"
)

{{- define "ParamFk" -}}
  {{$Model := . -}}
  {{ $idx := 0}}{{range .Fields }}{{if (isPk . $Model) -}}
    {{if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}} {{.GoType}}
  {{- end}}{{end}}
{{- end -}}

{{- define "ParamUnique" -}}
  {{- $p := .p}}{{ $idx := 0}}{{range .m.Fields }}{{if (inSlices $p.Fields .ID) -}}
    {{- if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}} {{.GoType -}}
  {{- end}}{{end}}
{{- end}}

type {{.ID}}Repository interface {
  Create(ctx context.Context, obj {{.ID}}) (*{{.ID}}, error)
  Get(ctx context.Context, {{template "ParamFk" . }}) (*{{.ID}}, error)
  {{range .Uniques -}}
  GetBy{{.ID}}(ctx context.Context, {{template "ParamUnique" (dict "m" $Model "p" .) }}) (*{{$Model.ID}}, error)
  {{- end}}
  FindOne(ctx context.Context, filter []{{.ID}}Filter, sort []{{.ID}}Sort) (*{{.ID}}, error)
  Find(ctx context.Context, filter []{{.ID}}Filter, sort []{{.ID}}Sort, limit int, offset int64) ([]{{.ID}}, int64, error)
  Update(ctx context.Context, obj {{.ID}}) error
  Delete(ctx context.Context, {{template "ParamFk" . }}) error
}

type {{.ID}}RepositoryImpl struct {
  *RepositoryImpl
}

func (r *{{.ID}}RepositoryImpl) Create(ctx context.Context, obj {{.ID}}) (*{{.ID}}, error) {
  tx, err := r.db.BeginTx(ctx, nil)
  if err != nil {
    return nil, err
  }
  defer tx.Rollback()
  sql := `
    INSERT INTO {{.Table}} (
      {{ $idx := 0 }}{{- range .Fields }}{{if not (eq .Type "autoincrement") -}}
      {{if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}{{.Field}}
      {{- end}}{{end}}
    ) VALUES (
      {{ $idx := 0 }}{{- range $i, $v := .Fields}}{{if not (eq .Type "autoincrement") -}}
      {{if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}${{$i}}
      {{- end}}{{end}}
    )`
  res, err := r.db.ExecContext(ctx, sql,
    {{- range .Fields }}{{if not (eq .Type "autoincrement") }}
    obj.{{.ID}},
    {{- end}}{{end}}
  )
  if err != nil {
    return nil, err
  }
  obj.ID, err = res.LastInsertId()
  if err != nil {
    return nil, err
  }
  err = tx.Commit()
  if err != nil {
    return nil, err
  }
  return &obj, nil
}

{{- define "SelectField" }}
  {{- range $idx, $v := .Fields -}}
  {{if gt $idx 0}},{{ "\n      " }}{{end}}{{.Field}}
  {{- end}}
{{- end}}

{{- define "ScanField" }}
  {{- range .Fields }}
    &obj.{{.ID}},
  {{- end}}
{{- end}}

{{- define "WhereFk" }}
  {{- $Model := . }}{{ $idx := 0 -}}
  {{- range .Fields -}}{{ if (inSlices $Model.PKeys .ID) -}}
    {{if gt $idx 0}} AND{{ "\n      " }}{{end}}{{$idx = add $idx 1}}{{.Field}} = ${{$idx}}
  {{- end}}{{- end}}
{{- end}}

{{- define "ArgFk" }}
  {{- $Model := . }}{{ $idx := 0 -}}
  {{- range .Fields -}}{{ if (inSlices $Model.PKeys .ID) -}}
    {{if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}}
  {{- end}}{{- end}}
{{- end}}

func (r *{{.ID}}RepositoryImpl) Get(ctx context.Context, {{template "ParamFk" . }}) (*{{.ID}}, error) {
  sql := `
    SELECT
      {{ template "SelectField" . }}
    FROM {{.Table}} WHERE
      {{ template "WhereFk" . }}`
  var obj {{.ID}};
  err := r.db.QueryRowContext(ctx, sql, {{ template "ArgFk" . }}).Scan(
    {{- template "ScanField" . }}
  )
  if err != nil {
    return nil, err
  }
  return &obj, nil
}

{{- define "WhereUnique" }}
  {{- $Model := .m }}{{ $idx := 0 -}}
  {{- $p := .p}}{{ $idx := 0}}{{range .m.Fields }}{{if (inSlices $p.Fields .ID) -}}
    {{if gt $idx 0}} AND{{ "\n      " }}{{end}}{{$idx = add $idx 1}}{{.Field}} = ${{$idx}}
  {{- end}}{{- end}}
{{- end}}

{{- define "ArgUnique" }}
  {{- $Model := .m }}{{ $idx := 0 -}}
  {{- $p := .p}}{{ $idx := 0}}{{range .m.Fields }}{{if (inSlices $p.Fields .ID) -}}
    {{if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}}
  {{- end}}{{- end}}
{{- end}}

{{range .Uniques -}}
func (r *{{$Model.ID}}RepositoryImpl) GetBy{{.ID}}(ctx context.Context, {{template "ParamUnique" (dict "m" $Model "p" .) }}) (*{{$Model.ID}}, error) {
  sql := `
    SELECT
      {{ template "SelectField" $Model }}
    FROM {{$Model.Table}} WHERE
      {{ template "WhereUnique" (dict "m" $Model "p" .) }}`
  var obj {{$Model.ID}};
  err := r.db.QueryRowContext(ctx, sql, {{ template "ArgUnique" (dict "m" $Model "p" .) }}).Scan(
    {{- template "ScanField" $Model }}
  )
  if err != nil {
    return nil, err
  }
  return &obj, nil
}
{{- end}}

{{define "FilterOp" -}}
  {{- $m := .m -}}
  {{- $res := .Res -}}
  for _, f := range filter {
    switch f.Field {
    {{range .m.Fields -}}{{if eq .Type "text" -}}
    case {{$m.ID}}Field_{{.ID}}:
      switch f.Op {
      case FilterOp_EQ:
        args = append(args, f.Value)
        qfilter = append(qfilter, "{{.Field}} = ?")
      case FilterOp_Like:
        args = append(args, f.Value)
        qfilter = append(qfilter, fmt.Sprintf("{{.Field}} LIKE $%d", len(args)))
      case FilterOp_ILike:
        args = append(args, f.Value)
        qfilter = append(qfilter, fmt.Sprintf("{{.Field}} ILIKE $%d", len(args)))
      default:
        return {{$res}}fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
      }
    {{end}}{{end -}}
    default:
      return {{$res}}fmt.Errorf("unsupported filter field %v", f.Field)
    }
  }
{{- end -}}

func (r *{{.ID}}RepositoryImpl) FindOne(ctx context.Context, filter []{{.ID}}Filter, sort []{{.ID}}Sort) (*{{.ID}}, error) {
  qfilter := []string{}
  args := []any{}
  {{template "FilterOp" (dict "m" . "Res" "nil, " )}}
  sql := `
    SELECT
      {{ template "SelectField" . }}
    FROM {{.Table}}`
  if len(qfilter) > 0 {
    sql += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
  }
  if len(sort) > 0 {
    sorts := []string{}
    for _, f := range sort {
      switch f.Field {
      {{range .Fields }}{{if eq .Type "text" -}}
      case {{$Model.ID}}Field_{{.ID}}:
        if f.Dir == SortDir_ASC {
          sorts = append(sorts, "{{.Field}} ASC")
        } else {
          sorts = append(sorts, "{{.Field}} DESC")
        }
      {{end}}{{end}}}
    }
    if len(sorts) > 0 {
      sql += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  sql += "\n  LIMIT 1"
  rows, err := r.db.QueryContext(ctx, sql, args...)
  if err != nil {
    slog.Error("Query list", "sql:", sql, "Error:", err)
    return nil, err
  }
  if rows.Next() {
    var obj {{.ID}};
    err = rows.Scan(
      {{- template "ScanField" . }}
    )
    if err != nil {
      return nil, err
    }
    return &obj, nil
  }
  return nil, fmt.Errorf("not found")
}

{{define "QueryFindCount" -}}
  {{$Model := . -}}
  SELECT COUNT(
  {{- $idx := 0}}{{range .Fields }}{{if (inSlices $Model.PKeys .ID) -}}
    {{if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}}
  {{- end}}{{end}})
  FROM {{.Table}}
{{- end -}}

func (r *{{.ID}}RepositoryImpl) Find(ctx context.Context, filter []{{.ID}}Filter, sort []{{.ID}}Sort, limit int, offset int64) ([]{{.ID}}, int64, error) {
  qfilter := []string{}
  args := []any{}
  {{template "FilterOp" (dict "m" . "Res" "nil, 0, " )}}
  sql := `{{template "QueryFindCount" .}}`
  if len(qfilter) > 0 {
    sql += " WHERE " + strings.Join(qfilter, " AND ")
  }
  total := int64(0)
  err := r.db.QueryRowContext(ctx, sql, args...).Scan(&total)
  if err != nil {
    slog.Error("Query count", "sql:", sql, "Error:", err)
    return nil, 0, err
  }
  sql = `
    SELECT
      {{ template "SelectField" . }}
    FROM {{.Table}}`
  if len(qfilter) > 0 {
    sql += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
  }
  if len(sort) > 0 {
    sorts := []string{}
    for _, f := range sort {
      switch f.Field {
      {{range .Fields }}{{if eq .Type "text" -}}
      case {{$Model.ID}}Field_{{.ID}}:
        if f.Dir == SortDir_ASC {
          sorts = append(sorts, "{{.Field}} ASC")
        } else {
          sorts = append(sorts, "{{.Field}} DESC")
        }
      {{end}}{{end}}}
    }
    if len(sorts) > 0 {
      sql += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  sql += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
  rows, err := r.db.QueryContext(ctx, sql, args...)
  if err != nil {
    slog.Error("Query list", "sql:", sql, "Error:", err)
    return nil, 0, err
  }
  list := []{{.ID}}{};
  for rows.Next() {
    var obj {{.ID}};
    err = rows.Scan(
      {{- template "ScanField" . }}
    )
    list = append(list, obj)
    if err != nil {
      return nil, total, err
    }
  }
  return list, total, nil
}

func (r *{{.ID}}RepositoryImpl) Update(ctx context.Context, obj {{.ID}}) error {
  tx, err := r.db.BeginTx(ctx, nil)
  if err != nil {
    return err
  }
  defer tx.Rollback()
  sql := `{{ $idx := 1 }}
    UPDATE {{.Table}} SET
      {{ range .Fields -}}{{if isUpdatable . $Model -}}
      {{if gt $idx 1}},{{"\n      "}}{{end}}{{.Field}} = ${{$idx}}{{$idx = add $idx 1}}
      {{- end}}{{end}}
    WHERE
      {{$fidx := $idx}}{{ range .Fields -}}{{if isPk . $Model -}}
      {{if gt $idx $fidx}},{{"\n      "}}{{end}}{{.Field}} = ${{$idx}}{{$idx = add $idx 1 -}}
      {{- end}}{{- end}}`
  res, err := r.db.ExecContext(ctx, sql,
    {{- range .Fields -}}{{if isUpdatable . $Model -}}
      {{"\n    "}}obj.{{.ID}},
    {{- end}}{{end}}
    {{- range .Fields -}}{{if (isPk . $Model) -}}
      {{"\n    "}}obj.{{.ID}},
    {{- end}}{{end}}
  )
  if err != nil {
    return err
  }
  ra, err := res.RowsAffected()
  if err != nil {
    return err
  }
  if ra == 0 {
    return fmt.Errorf("no rows affected")
  }
  if ra != 1 {
    return fmt.Errorf("invalid rows affected (%d)", ra)
  }
  err = tx.Commit()
  if err != nil {
    return err
  }
  return nil
}

func (r *{{.ID}}RepositoryImpl) Delete(ctx context.Context, {{template "ParamFk" . }}) error {
  sql := `
    DELETE FROM {{.Table}} WHERE
      {{ template "WhereFk" . }}`
  res, err := r.db.ExecContext(ctx, sql, {{ template "ArgFk" .}})
  if err != nil {
    return err
  }
  ra, err := res.RowsAffected()
  if err != nil {
    return err
  }
  if ra == 0 {
    return fmt.Errorf("no rows affected")
  }
  if ra != 1 {
    return fmt.Errorf("invalid rows affected (%d)", ra)
  }
  return nil
}
