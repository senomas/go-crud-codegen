// Code generated by apigen. DO NOT EDIT.

{{$Model := . -}}
package {{.Package}}

import (
  "log/slog"
)

{{- define "ParamFk" -}}
  {{$Model := . -}}
  {{ $idx := 0}}{{range .Fields }}{{if (isPk . $Model) -}}
    {{if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}} {{goType .}}
  {{- end}}{{end}}
{{- end -}}

{{- define "ParamUnique" -}}
  {{- $p := .p}}{{ $idx := 0}}{{range .m.Fields }}{{if (inSlices $p.Fields .ID) -}}
    {{- if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}} {{goType . -}}
  {{- end}}{{end}}
{{- end}}

type {{.ID}}Repository interface {
  Create(ctx context.Context, obj {{.ID}}) (*{{.ID}}, error)
  Get(ctx context.Context, {{template "ParamFk" . }}) (*{{.ID}}, error)
  {{range .Uniques -}}
  GetBy{{.ID}}(ctx context.Context, {{template "ParamUnique" (dict "m" $Model "p" .) }}) (*{{$Model.ID}}, error)
  {{- end}}
  FindOne(ctx context.Context, filter []{{.ID}}Filter, sort []{{.ID}}Sort) (*{{.ID}}, error)
  Find(ctx context.Context, filter []{{.ID}}Filter, sort []{{.ID}}Sort, limit int, offset int64) ([]{{.ID}}, int64, error)
  Update(ctx context.Context, obj {{.ID}}, fields []{{.ID}}Field) error
  Delete(ctx context.Context, {{template "ParamFk" . }}) error
}

type {{.ID}}RepositoryImpl struct {
  *RepositoryImpl
}

func (r *{{.ID}}RepositoryImpl) Create(ctx context.Context, obj {{.ID}}) (*{{.ID}}, error) {
  var tx *sql.Tx
  var err error
  var txNew bool
  tx, err = r.db.BeginTx(ctx, nil)
  txNew = true
  defer tx.Rollback()
  qry := `
    INSERT INTO {{.Table}} (
      {{ $idx := 0 }}{{- range .Fields }}{{if not (eq .Type "autoincrement") -}}
      {{if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}{{.Field}}
      {{- end}}{{end}}
    ) VALUES (
      {{ $idx := 0 }}{{- range $i, $v := .Fields}}{{if not (eq .Type "autoincrement") -}}
      {{if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}${{$i}}
      {{- end}}{{end}}
    )`
  {{- range .Fields -}}{{$fb := . -}}
    {{- if eq .Type "many-to-one" }}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refKeys .ID) -}}
        {{"\n    "}}var obj{{$fb.ID}}_{{.ID}} *{{goType .}}
        if obj.{{$fb.ID}} != nil {
          obj{{$fb.ID}}_{{.ID}} = &obj.{{$fb.ID}}.{{.ID}}
        }
      {{- end}}{{end}}
    {{- end}}
  {{- end}}
  res, err := tx.ExecContext(ctx, qry,
    {{- range .Fields -}}{{$f := . -}}
      {{- if eq .Type "autoincrement" -}}
      {{- else if eq .Type "many-to-one" }}{{$fb := . }}
        {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refKeys .ID) }}
          obj{{$fb.ID}}_{{.ID}},
        {{- end}}{{end}}
      {{-  else }}
        obj.{{.ID}},
      {{- end}}
    {{- end}}
  )
  if err != nil {
    return nil, err
  }
  obj.ID, err = res.LastInsertId()
  if err != nil {
    return nil, err
  }
  if txNew {
    err = tx.Commit()
    if err != nil {
      return nil, err
    }
  }
  return &obj, nil
}

{{- define "SelectField" }}
  {{- $Model := .}}{{$idx := 0}}{{range .Fields -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refKeys .ID) }}
        {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1}}
        {{- "obj"}}{{$fb.ID}}.{{- .Field}}
      {{- end}}{{end}}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refFields .ID) }}
        {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1}}
        {{- "obj"}}{{$fb.ID}}.{{- .Field}}
      {{- end}}{{end}}
    {{-  else }}
      {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1}}
      {{- "obj."}}{{.Field}}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "SelectFrom" }}
  {{- $Model := .}}{{range .Fields -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- "("}}
    {{- end}}
  {{- end}}
  {{- .Table}} obj
  {{- $Model := .}}{{$ridx := 0}}{{range .Fields -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- if gt $ridx 0}}
        {{- "\n      LEFT JOIN "}}
      {{- else }}
        {{- " LEFT JOIN "}}
      {{- end}}{{ $ridx = add $ridx 1 }}
      {{- (model $Model .).Table }} obj{{$fb.ID}}{{ " ON" -}}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refKeys .ID) }}
        {{- " " }}obj.{{$fb.Field}} = obj{{$fb.ID}}.{{.Field}}
      {{- end}}{{end}}
      {{- ")" }}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "ScanFieldDef" }}
  {{- $Model := . }}
  {{- $idx:=0}}{{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refKeys .ID) }}
        {{- if gt $idx 0}}{{"\n  "}}{{end}}{{$idx = add $idx 1}}var ref{{$fb.ID}}_{{.ID}} {{goSqlNullType .}}
      {{- end}}{{end}}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refFields .ID) }}
        {{- if gt $idx 0}}{{"\n  "}}{{end}}{{$idx = add $idx 1}}var ref{{$fb.ID}}_{{.ID}} {{goSqlNullType .}}
      {{- end}}{{end}}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "ScanField" }}
  {{- $Model := . }}
  {{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refKeys .ID) }}
        &ref{{$fb.ID}}_{{.ID}},
      {{- end}}{{end}}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refFields .ID) }}
        &ref{{$fb.ID}}_{{.ID}},
      {{- end}}{{end}}
    {{-  else }}
      &obj.{{.ID}},
    {{- end}}
  {{- end}}
{{- end}}

{{- define "ScanFieldRef" -}}
  {{- $Model := . -}}
  {{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refKeys .ID) }}
        if ref{{$fb.ID}}_{{.ID}}.Valid {
        	obj.{{$fb.ID}} = &User{ {{.ID}}: ref{{$fb.ID}}_{{.ID}}{{goSqlNullValue .}}}
        }
      {{- end}}{{end}}
      {{- range $Model.Fields -}}{{if (inSlices $fb.Extras.refFields .ID) }}
        if obj.{{$fb.ID}} != nil && ref{{$fb.ID}}_{{.ID}}.Valid {
        	obj.{{$fb.ID}}.{{.ID}} = ref{{$fb.ID}}_{{.ID}}{{goSqlNullValue .}}
        }
      {{- end}}{{end}}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "WhereFk" }}
  {{- $Model := . }}{{ $idx := 0 -}}
  {{- range .Fields -}}{{ if (inSlices $Model.PKeys .ID) -}}
    {{if gt $idx 0}} AND{{ "\n      " }}{{end}}{{$idx = add $idx 1}}obj.{{.Field}} = ${{$idx}}
  {{- end}}{{- end}}
{{- end}}

{{- define "ArgFk" }}
  {{- $Model := . }}{{ $idx := 0 -}}
  {{- range .Fields -}}{{ if (inSlices $Model.PKeys .ID) -}}
    {{if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}}
  {{- end}}{{- end}}
{{- end}}

func (r *{{.ID}}RepositoryImpl) Get(ctx context.Context, {{template "ParamFk" . }}) (*{{.ID}}, error) {
  qry := `
    SELECT
      {{ template "SelectField" . }}
    FROM
      {{template "SelectFrom" . }}
    WHERE
      {{ template "WhereFk" . }}`
  var obj {{.ID}};
  {{template "ScanFieldDef" .}}
  err := r.db.QueryRowContext(ctx, qry, {{ template "ArgFk" . }}).Scan(
    {{- template "ScanField" . }}
  )
  if err != nil {
    return nil, err
  }
  {{- template "ScanFieldRef" .}}
  return &obj, nil
}

{{- define "WhereUnique" }}
  {{- $Model := .m }}{{ $idx := 0 -}}
  {{- $p := .p}}{{ $idx := 0}}{{range .m.Fields }}{{if (inSlices $p.Fields .ID) -}}
    {{if gt $idx 0}} AND{{ "\n      " }}{{end}}{{$idx = add $idx 1}}obj.{{.Field}} = ${{$idx}}
  {{- end}}{{- end}}
{{- end}}

{{- define "ArgUnique" }}
  {{- $Model := .m }}{{ $idx := 0 -}}
  {{- $p := .p}}{{ $idx := 0}}{{range .m.Fields }}{{if (inSlices $p.Fields .ID) -}}
    {{if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}}
  {{- end}}{{- end}}
{{- end}}

{{range .Uniques -}}
func (r *{{$Model.ID}}RepositoryImpl) GetBy{{.ID}}(ctx context.Context, {{template "ParamUnique" (dict "m" $Model "p" .) }}) (*{{$Model.ID}}, error) {
  qry := `
    SELECT
      {{ template "SelectField" $Model }}
    FROM
      {{template "SelectFrom" $Model }}
    WHERE
      {{ template "WhereUnique" (dict "m" $Model "p" .) }}`
  var obj {{$Model.ID}};
  {{template "ScanFieldDef" $Model}}
  err := r.db.QueryRowContext(ctx, qry, {{ template "ArgUnique" (dict "m" $Model "p" .) }}).Scan(
    {{- template "ScanField" $Model }}
  )
  if err != nil {
    return nil, err
  }
  {{- template "ScanFieldRef" $Model}}
  return &obj, nil
}
{{- end}}

{{define "FilterOp" -}}
  {{- $m := .m -}}
  {{- $res := .Res -}}
  for _, f := range filter {
    switch f.Field {
    {{range .m.Fields -}}{{if eq .Type "text" -}}
    case {{$m.ID}}Field_{{.ID}}:
      switch f.Op {
      case FilterOp_EQ:
        args = append(args, f.Value)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} = $%d", len(args)))
      case FilterOp_Like:
        args = append(args, f.Value)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} LIKE $%d", len(args)))
      case FilterOp_ILike:
        args = append(args, f.Value)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} ILIKE $%d", len(args)))
      default:
        return {{$res}}fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
      }
    {{end}}{{end -}}
    default:
      return {{$res}}fmt.Errorf("unsupported filter field %v", f.Field)
    }
  }
{{- end -}}

func (r *{{.ID}}RepositoryImpl) FindOne(ctx context.Context, filter []{{.ID}}Filter, sort []{{.ID}}Sort) (*{{.ID}}, error) {
  qfilter := []string{}
  args := []any{}
  {{template "FilterOp" (dict "m" . "Res" "nil, " )}}
  qry := `
    SELECT
      {{ template "SelectField" . }}
    FROM
      {{template "SelectFrom" . }}`
  if len(qfilter) > 0 {
    qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
  }
  if len(sort) > 0 {
    sorts := []string{}
    for _, f := range sort {
      switch f.Field {
      {{range .Fields }}{{if eq .Type "text" -}}
      case {{$Model.ID}}Field_{{.ID}}:
        if f.Dir == SortDir_ASC {
          sorts = append(sorts, "obj.{{.Field}} ASC")
        } else {
          sorts = append(sorts, "obj.{{.Field}} DESC")
        }
      {{end}}{{end}}}
    }
    if len(sorts) > 0 {
      qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  qry += "\n  LIMIT 1"
  rows, err := r.db.QueryContext(ctx, qry, args...)
  if err != nil {
    slog.Error("Query list", "qry:", qry, "Error:", err)
    return nil, err
  }
  if rows.Next() {
    var obj {{.ID}};
    {{template "ScanFieldDef" .}}
    err = rows.Scan(
      {{- template "ScanField" . }}
    )
    if err != nil {
      return nil, err
    }
    {{- template "ScanFieldRef" .}}
    return &obj, nil
  }
  return nil, fmt.Errorf("not found")
}

{{define "QueryFindCount" -}}
  {{$Model := . -}}
  SELECT COUNT(
  {{- $idx := 0}}{{range .Fields }}{{if (inSlices $Model.PKeys .ID) -}}
    {{if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}obj.{{.Field}}
  {{- end}}{{end}})
  FROM {{.Table}} obj
{{- end -}}

func (r *{{.ID}}RepositoryImpl) Find(ctx context.Context, filter []{{.ID}}Filter, sort []{{.ID}}Sort, limit int, offset int64) ([]{{.ID}}, int64, error) {
  qfilter := []string{}
  args := []any{}
  {{template "FilterOp" (dict "m" . "Res" "nil, 0, " )}}
  qry := `{{template "QueryFindCount" .}}`
  if len(qfilter) > 0 {
    qry += " WHERE " + strings.Join(qfilter, " AND ")
  }
  total := int64(0)
  err := r.db.QueryRowContext(ctx, qry, args...).Scan(&total)
  if err != nil {
    slog.Error("Query count", "qry:", qry, "Error:", err)
    return nil, 0, err
  }
  qry = `
    SELECT
      {{ template "SelectField" . }}
    FROM
      {{template "SelectFrom" . }}`
  if len(qfilter) > 0 {
    qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
  }
  if len(sort) > 0 {
    sorts := []string{}
    for _, f := range sort {
      switch f.Field {
      {{range .Fields }}{{if eq .Type "text" -}}
      case {{$Model.ID}}Field_{{.ID}}:
        if f.Dir == SortDir_ASC {
          sorts = append(sorts, "obj.{{.Field}} ASC")
        } else {
          sorts = append(sorts, "obj.{{.Field}} DESC")
        }
      {{end}}{{end}}}
    }
    if len(sorts) > 0 {
      qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  qry += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
  rows, err := r.db.QueryContext(ctx, qry, args...)
  if err != nil {
    slog.Error("Query list", "qry:", qry, "Error:", err)
    return nil, 0, err
  }
  list := []{{.ID}}{};
  for rows.Next() {
    var obj {{.ID}};
    {{template "ScanFieldDef" .}}
    err = rows.Scan(
      {{- template "ScanField" . }}
    )
    if err != nil {
      return nil, total, err
    }
    {{- template "ScanFieldRef" .}}
    list = append(list, obj)
  }
  return list, total, nil
}

func (r *{{.ID}}RepositoryImpl) Update(ctx context.Context, obj {{.ID}}, fields []{{.ID}}Field) error {
  var tx *sql.Tx
  var err error
  var txNew bool
  tx, err = r.db.BeginTx(ctx, nil)
  if err != nil {
    return err
  }
  txNew = true
  defer tx.Rollback()
  args := []any{}
  qry := `UPDATE {{.Table}} SET`
  nf := false
  for _, f := range fields {
    if nf {
      qry += ",\n      "
    } else {
      qry += "\n      "
      nf = true
    }
    switch f {
    {{- range .Fields}}{{if isUpdatable . $Model }}
    case {{$Model.ID}}Field_{{.ID}}:
      args = append(args, obj.{{.ID}})
      qry += fmt.Sprintf("  {{.Field}} = $%d", len(args))
    {{- end}}{{end}}
    default:
      return fmt.Errorf("field %v is unknown", f)
    }
  }
  qry += "\nWHERE\n"
  {{$idx := 0}}{{ range .Fields -}}{{if isPk . $Model -}}
    args = append(args, obj.{{.ID}})
    qry += fmt.Sprintf("{{if gt $idx 0}} AND\n{{end}}  {{.Field}} = $%d{{$idx = add $idx 1}}", len(args))
  {{- end}}{{- end}}
  {{ range .Fields -}}{{if eq .Type "version" -}}
    args = append(args, obj.{{.ID}})
    qry += fmt.Sprintf("{{if gt $idx 0}} AND\n{{end}}  {{.Field}} = $%d{{$idx = add $idx 1}}", len(args))
  {{- end}}{{- end}}
  res, err := tx.ExecContext(ctx, qry, args...)
  if err != nil {
    slog.Error("Update", "qry:", qry, "Error:", err)
    return err
  }
  ra, err := res.RowsAffected()
  if err != nil {
    slog.Error("Update", "qry:", qry, "args:", args, "Error:", err)
    return err
  }
  if ra == 0 {
    slog.Error("Update", "qry:", qry, "args:", args, "Error:", err)
    return fmt.Errorf("no rows affected")
  }
  if ra != 1 {
    slog.Error("Update", "qry:", qry, "args:", args, "Error:", err)
    return fmt.Errorf("invalid rows affected (%d)", ra)
  }
  if txNew {
    err = tx.Commit()
    if err != nil {
      return err
    }
  }
  return nil
}

func (r *{{.ID}}RepositoryImpl) Delete(ctx context.Context, {{template "ParamFk" . }}) error {
  var tx *sql.Tx
  var err error
  var txNew bool
  tx, err = r.db.BeginTx(ctx, nil)
  if err != nil {
    return err
  }
  txNew = true
  qry := `
    DELETE FROM {{.Table}} WHERE
      {{ template "WhereFk" . }}`
  res, err := tx.ExecContext(ctx, qry, {{ template "ArgFk" .}})
  if err != nil {
    return err
  }
  ra, err := res.RowsAffected()
  if err != nil {
    return err
  }
  if ra == 0 {
    return fmt.Errorf("no rows affected")
  }
  if ra != 1 {
    return fmt.Errorf("invalid rows affected (%d)", ra)
  }
  if txNew {
    err = tx.Commit()
    if err != nil {
      return err
    }
  }
  return nil
}
