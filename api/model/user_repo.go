// Code generated by apigen. DO NOT EDIT.

package model

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"
	"strings"
)

type UserRepository interface {
	Create(ctx context.Context, obj User) (*User, error)
	Get(ctx context.Context, id int64) (*User, error)
	GetByName(ctx context.Context, name string) (*User, error)
	FindOne(ctx context.Context, filter []UserFilter, sort []UserSort) (*User, error)
	Find(ctx context.Context, filter []UserFilter, sort []UserSort, limit int, offset int64) ([]User, int64, error)
	Update(ctx context.Context, obj User) error
	Delete(ctx context.Context, id int64) error
}

type UserRepositoryImpl struct {
	*RepositoryImpl
}

func (r *UserRepositoryImpl) Create(ctx context.Context, obj User) (*User, error) {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	qry := `
    INSERT INTO app_user (
      email,
      name,
      salt,
      password,
      token,
      created_by
    ) VALUES (
      $1,
      $2,
      $3,
      $4,
      $5,
      $6
    )`
	var objCreatedBy_ID *int64
	if obj.CreatedBy != nil {
		objCreatedBy_ID = &obj.CreatedBy.ID
	}
	res, err := r.db.ExecContext(ctx, qry,
		obj.Email,
		obj.Name,
		obj.Salt,
		obj.Password,
		obj.Token,
		objCreatedBy_ID,
	)
	if err != nil {
		return nil, err
	}
	obj.ID, err = res.LastInsertId()
	if err != nil {
		return nil, err
	}
	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	return &obj, nil
}

func (r *UserRepositoryImpl) Get(ctx context.Context, id int64) (*User, error) {
	qry := `
    SELECT
      id,
      email,
      name,
      salt,
      password,
      token,
      created_by
    FROM app_user WHERE
      id = $1`
	var obj User
	var objCreatedBy_ID sql.NullInt64
	err := r.db.QueryRowContext(ctx, qry, id).Scan(
		&obj.ID,
		&obj.Email,
		&obj.Name,
		&obj.Salt,
		&obj.Password,
		&obj.Token,
		&objCreatedBy_ID,
	)
	if err != nil {
		return nil, err
	}
	if objCreatedBy_ID.Valid {
		obj.CreatedBy = &User{ID: objCreatedBy_ID.Int64}
	}
	return &obj, nil
}

func (r *UserRepositoryImpl) GetByName(ctx context.Context, name string) (*User, error) {
	qry := `
    SELECT
      id,
      email,
      name,
      salt,
      password,
      token,
      created_by
    FROM app_user WHERE
      name = $1`
	var obj User
	var objCreatedBy_ID sql.NullInt64
	err := r.db.QueryRowContext(ctx, qry, name).Scan(
		&obj.ID,
		&obj.Email,
		&obj.Name,
		&obj.Salt,
		&obj.Password,
		&obj.Token,
		&objCreatedBy_ID,
	)
	if err != nil {
		return nil, err
	}
	if objCreatedBy_ID.Valid {
		obj.CreatedBy = &User{ID: objCreatedBy_ID.Int64}
	}
	return &obj, nil
}

func (r *UserRepositoryImpl) FindOne(ctx context.Context, filter []UserFilter, sort []UserSort) (*User, error) {
	qfilter := []string{}
	args := []any{}
	for _, f := range filter {
		switch f.Field {
		case UserField_Email:
			switch f.Op {
			case FilterOp_EQ:
				args = append(args, f.Value)
				qfilter = append(qfilter, "email = ?")
			case FilterOp_Like:
				args = append(args, f.Value)
				qfilter = append(qfilter, fmt.Sprintf("email LIKE $%d", len(args)))
			case FilterOp_ILike:
				args = append(args, f.Value)
				qfilter = append(qfilter, fmt.Sprintf("email ILIKE $%d", len(args)))
			default:
				return nil, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		case UserField_Name:
			switch f.Op {
			case FilterOp_EQ:
				args = append(args, f.Value)
				qfilter = append(qfilter, "name = ?")
			case FilterOp_Like:
				args = append(args, f.Value)
				qfilter = append(qfilter, fmt.Sprintf("name LIKE $%d", len(args)))
			case FilterOp_ILike:
				args = append(args, f.Value)
				qfilter = append(qfilter, fmt.Sprintf("name ILIKE $%d", len(args)))
			default:
				return nil, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		default:
			return nil, fmt.Errorf("unsupported filter field %v", f.Field)
		}
	}
	qry := `
    SELECT
      id,
      email,
      name,
      salt,
      password,
      token,
      created_by
    FROM app_user`
	if len(qfilter) > 0 {
		qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
	}
	if len(sort) > 0 {
		sorts := []string{}
		for _, f := range sort {
			switch f.Field {
			case UserField_Email:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "email ASC")
				} else {
					sorts = append(sorts, "email DESC")
				}
			case UserField_Name:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "name ASC")
				} else {
					sorts = append(sorts, "name DESC")
				}
			}
		}
		if len(sorts) > 0 {
			qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
		}
	}
	qry += "\n  LIMIT 1"
	rows, err := r.db.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Query list", "qry:", qry, "Error:", err)
		return nil, err
	}
	if rows.Next() {
		var obj User
		var objCreatedBy_ID sql.NullInt64
		err = rows.Scan(
			&obj.ID,
			&obj.Email,
			&obj.Name,
			&obj.Salt,
			&obj.Password,
			&obj.Token,
			&objCreatedBy_ID,
		)
		if err != nil {
			return nil, err
		}
		if objCreatedBy_ID.Valid {
			obj.CreatedBy = &User{ID: objCreatedBy_ID.Int64}
		}
		return &obj, nil
	}
	return nil, fmt.Errorf("not found")
}

func (r *UserRepositoryImpl) Find(ctx context.Context, filter []UserFilter, sort []UserSort, limit int, offset int64) ([]User, int64, error) {
	qfilter := []string{}
	args := []any{}
	for _, f := range filter {
		switch f.Field {
		case UserField_Email:
			switch f.Op {
			case FilterOp_EQ:
				args = append(args, f.Value)
				qfilter = append(qfilter, "email = ?")
			case FilterOp_Like:
				args = append(args, f.Value)
				qfilter = append(qfilter, fmt.Sprintf("email LIKE $%d", len(args)))
			case FilterOp_ILike:
				args = append(args, f.Value)
				qfilter = append(qfilter, fmt.Sprintf("email ILIKE $%d", len(args)))
			default:
				return nil, 0, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		case UserField_Name:
			switch f.Op {
			case FilterOp_EQ:
				args = append(args, f.Value)
				qfilter = append(qfilter, "name = ?")
			case FilterOp_Like:
				args = append(args, f.Value)
				qfilter = append(qfilter, fmt.Sprintf("name LIKE $%d", len(args)))
			case FilterOp_ILike:
				args = append(args, f.Value)
				qfilter = append(qfilter, fmt.Sprintf("name ILIKE $%d", len(args)))
			default:
				return nil, 0, fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
			}
		default:
			return nil, 0, fmt.Errorf("unsupported filter field %v", f.Field)
		}
	}
	qry := `SELECT COUNT(id)
  FROM app_user`
	if len(qfilter) > 0 {
		qry += " WHERE " + strings.Join(qfilter, " AND ")
	}
	total := int64(0)
	err := r.db.QueryRowContext(ctx, qry, args...).Scan(&total)
	if err != nil {
		slog.Error("Query count", "qry:", qry, "Error:", err)
		return nil, 0, err
	}
	qry = `
    SELECT
      id,
      email,
      name,
      salt,
      password,
      token,
      created_by
    FROM app_user`
	if len(qfilter) > 0 {
		qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
	}
	if len(sort) > 0 {
		sorts := []string{}
		for _, f := range sort {
			switch f.Field {
			case UserField_Email:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "email ASC")
				} else {
					sorts = append(sorts, "email DESC")
				}
			case UserField_Name:
				if f.Dir == SortDir_ASC {
					sorts = append(sorts, "name ASC")
				} else {
					sorts = append(sorts, "name DESC")
				}
			}
		}
		if len(sorts) > 0 {
			qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
		}
	}
	qry += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
	rows, err := r.db.QueryContext(ctx, qry, args...)
	if err != nil {
		slog.Error("Query list", "qry:", qry, "Error:", err)
		return nil, 0, err
	}
	list := []User{}
	for rows.Next() {
		var obj User
		var objCreatedBy_ID sql.NullInt64
		err = rows.Scan(
			&obj.ID,
			&obj.Email,
			&obj.Name,
			&obj.Salt,
			&obj.Password,
			&obj.Token,
			&objCreatedBy_ID,
		)
		if err != nil {
			return nil, total, err
		}
		if objCreatedBy_ID.Valid {
			obj.CreatedBy = &User{ID: objCreatedBy_ID.Int64}
		}
		list = append(list, obj)
	}
	return list, total, nil
}

func (r *UserRepositoryImpl) Update(ctx context.Context, obj User) error {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	qry := `
    UPDATE app_user SET
      email = $1,
      name = $2,
      token = $3,
      created_by = $4
    WHERE
      id = $5`
	res, err := r.db.ExecContext(ctx, qry,
		obj.Email,
		obj.Name,
		obj.Token,
		obj.CreatedBy,
		obj.ID,
	)
	if err != nil {
		return err
	}
	ra, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if ra == 0 {
		return fmt.Errorf("no rows affected")
	}
	if ra != 1 {
		return fmt.Errorf("invalid rows affected (%d)", ra)
	}
	err = tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (r *UserRepositoryImpl) Delete(ctx context.Context, id int64) error {
	qry := `
    DELETE FROM app_user WHERE
      id = $1`
	res, err := r.db.ExecContext(ctx, qry, id)
	if err != nil {
		return err
	}
	ra, err := res.RowsAffected()
	if err != nil {
		return err
	}
	if ra == 0 {
		return fmt.Errorf("no rows affected")
	}
	if ra != 1 {
		return fmt.Errorf("invalid rows affected (%d)", ra)
	}
	return nil
}
