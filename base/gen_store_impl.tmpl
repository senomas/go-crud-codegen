{{- define "GetSelectField" }}
  {{- $idx := 0}}{{range .Fields -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range .RefKeys}}
        {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1}}
        {{- "obj"}}{{$fb.ID}}.{{- .Ref.Field}}
      {{- end}}
      {{- range .RefFields}}
        {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1}}
        {{- "obj"}}{{$fb.ID}}.{{- .Ref.Field}}
      {{- end}}
    {{- else if eq .Type "many-to-many" }}{{$fb := . }}
      {{- range .RefKeys -}}
        {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1 -}}
        obj{{$fb.ID}}_ref.{{ .Ref.Field}}
      {{- end}}
      {{- range .RefFields -}}
        {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1 -}}
        obj{{$fb.ID}}_ref.{{ .Ref.Field}}
      {{- end}}
    {{-  else }}
      {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1}}
      {{- "obj."}}{{.Field}}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "GetSelectFrom" }}
  {{- $ridx:=0}}{{range .Fields -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- "("}}
    {{- else if eq .Type "many-to-many" }}{{$fb := . }}
      {{- "(("}}
    {{- end}}
   {{- end}}
  {{- .Table}} obj
  {{- range .Fields -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- if gt $ridx 0}}
        {{- "\n      LEFT JOIN "}}
      {{- else }}
        {{- " LEFT JOIN "}}
      {{- end}}{{ $ridx = add $ridx 1 }}
      {{- .Model.Table }} obj{{$fb.ID}}{{ " ON" -}}
      {{- range .RefKeys}}
        {{- " " }}obj.{{$fb.Field}} = obj{{$fb.ID}}.{{.Ref.Field}}
      {{- end}}
      {{- ")" }}
    {{- else if eq .Type "many-to-many" }}{{$fb := . }}
      {{- if gt $ridx 0}}
        {{- "\n      LEFT JOIN "}}
      {{- else }}
        {{- " LEFT JOIN "}}
      {{- end}}{{ $ridx = add $ridx 1 }}
      {{- .MapTable}} obj{{.ID}}
      {{- " ON " -}}
      {{- $fidx := 0}}{{range .MapKeys}}
        {{- if gt $fidx 0}} AND {{end}}{{$fidx = add $fidx 1}}
        {{- "obj." }}{{ .Ref.Field }}{{ " = " -}} obj{{$fb.ID}}.{{ .Field }}
      {{- end}}
      {{- ")" }}
      {{- "\n      LEFT JOIN "}}
      {{- .RefModel.Table }} obj{{$fb.ID}}{{ "_ref ON "}}
      {{- $fidx := 0}}{{range .RefKeys}}
        {{- if gt $fidx 0}} AND {{end}}{{$fidx = add $fidx 1}}
        {{- "obj" }}{{$fb.ID}}_ref.{{ .Ref.Field}} = obj{{$fb.ID}}.{{ .Field }}
      {{- end}}
       {{- ")" }}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "GetScanFieldDef" }}
  {{- $idx:=0}}{{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range .RefKeys}}
        {{- if gt $idx 0}}{{"\n  "}}{{end}}{{$idx = add $idx 1 -}}
        var ref{{$fb.ID}}_{{.Ref.ID}} {{.Ref.GoSqlNullType }}
      {{- end}}
      {{- range .RefFields}}
        {{- if gt $idx 0}}{{"\n  "}}{{end}}{{$idx = add $idx 1 -}}
        var ref{{$fb.ID}}_{{.Ref.ID}} {{.Ref.GoSqlNullType }}
      {{- end}}
    {{- else if eq .Type "many-to-many" }}{{$fb := . }}
      {{- if gt $idx 0}}{{"\n  "}}{{end}}{{$idx = add $idx 1 -}}
      var ref{{.ID}} *{{.Ref}}
      {{- range .RefKeys -}}
        {{- if gt $idx 0}}{{"\n  "}}{{end}}{{$idx = add $idx 1 -}}
        var ref{{$fb.ID}}_{{.Ref.ID}} {{.Ref.GoSqlNullType }}
      {{- end}}
      {{- range .RefFields -}}
        {{- if gt $idx 0}}{{"\n  "}}{{end}}{{$idx = add $idx 1 -}}
        var ref{{$fb.ID}}_{{.Ref.ID}} {{.Ref.GoSqlNullType }}
      {{- end}}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "GetScanField" }}
  {{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range .RefKeys}}
        &ref{{$fb.ID}}_{{.Ref.ID}},
      {{- end}}
      {{- range .RefFields}}
        &ref{{$fb.ID}}_{{.Ref.ID}},
      {{- end}}
    {{- else if eq .Type "many-to-many" }}
      {{- range .RefKeys}}
        &ref{{$f.ID}}_{{.Ref.ID}},
      {{- end}}
      {{- range .RefFields }}
        &ref{{$f.ID}}_{{.Ref.ID}},
      {{- end}}
    {{-  else }}
      &obj.{{.ID}},
    {{- end}}
  {{- end}}
{{- end}}

{{- define "GetScanFieldRef" -}}
  {{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range .RefKeys}}
        if ref{{$fb.ID}}_{{.Ref.ID}}.Valid {
          if obj.{{$fb.ID}} == nil {
        	  obj.{{$fb.ID}} = &User{ {{.Ref.ID}}: ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue }}}
          } else {
        	  obj.{{$fb.ID}}.{{.Ref.ID}} = ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue }}
          }
        }
      {{- end}}
      {{- range .RefFields}}
        if ref{{$fb.ID}}_{{.Ref.ID}}.Valid {
          obj.{{$fb.ID}}.{{.Ref.ID}} = ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue }}
        }
      {{- end}}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "GetScanFieldManyRef" -}}
  {{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
    {{- else if eq .Type "many-to-many" }}{{$fb := . }}
      {{$fidx := 0}}{{- range .RefKeys }}
        if ref{{$fb.ID}}_{{.Ref.ID}}.Valid {
          {{- if gt $fidx 0}}
          if ref{{$fb.ID}} == nil {
            ref{{$fb.ID}} = &{{$fb.Ref}}{ {{.Ref.ID}}: ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue }} }
          } else {
            ref{{$fb.ID}}.{{.Ref.ID}} = ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue }}
          }
          {{- else}}
          ref{{$fb.ID}} = &{{$fb.Ref}}{ {{.Ref.ID}}: ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue }} }
          {{- end}}{{$fidx = add $fidx 1}}
        }
      {{- end}}
      {{- range .RefFields }}
        if ref{{$fb.ID}} != nil && ref{{$fb.ID}}_{{.Ref.ID}}.Valid {
          ref{{$fb.ID}}.{{.Ref.ID}} = ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue }}
        }
      {{- end}}
      if ref{{$fb.ID}} != nil {
        obj.{{$fb.ID}} = append(obj.{{$fb.ID}}, *ref{{$fb.ID}})
        ref{{$fb.ID}} = nil
      }
    {{- end}}
  {{- end}}
{{- end}}

{{- define "WhereFk" }}
  {{- $idx := 0 -}}
  {{- range .PKeys -}}
    {{if gt $idx 0}} AND{{ "\n      " }}{{end}}{{$idx = add $idx 1}}obj.{{.Field}} = {{ template "QryParam" $idx}}
  {{- end}}
{{- end}}

{{- define "ArgFk" }}
  {{- $idx := 0 -}}
  {{- range .PKeys -}}
    {{- if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}}
  {{- end}}
{{- end}}

{{- define "WhereUnique" }}
  {{- $idx := 0}}{{range .Fields -}}
    {{if gt $idx 0}} AND{{ "\n      " }}{{end}}{{$idx = add $idx 1}}obj.{{.Field}} = {{ template "QryParam" $idx}}
  {{- end}}
{{- end}}

{{- define "ArgUnique" }}
  {{- $idx := 0}}{{range .Fields -}}
    {{if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}{{.Field}}
  {{- end}}
{{- end}}

{{- define "SelectField" -}}
  {{- $idx := 0}}{{range .Fields -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range .RefKeys }}
        {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1}}
        {{- "obj"}}{{$fb.ID}}.{{- .Ref.Field}}
      {{- end}}
      {{- range .RefFields }}
        {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1}}
        {{- "obj"}}{{$fb.ID}}.{{- .Ref.Field}}
      {{- end}}
    {{- else if eq .Type "many-to-many" }}
    {{-  else }}
      {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{$idx = add $idx 1}}
      {{- "obj."}}{{.Field}}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "SelectFrom" }}
  {{- range .Fields -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- "("}}
    {{- end}}
  {{- end}}
  {{- .Table}} obj
  {{- $ridx := 0}}{{range .Fields -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- if gt $ridx 0}}
        {{- "\n      LEFT JOIN "}}
      {{- else }}
        {{- " LEFT JOIN "}}
      {{- end}}{{ $ridx = add $ridx 1 }}
      {{- .Model.Table }} obj{{$fb.ID}}{{ " ON" -}}
      {{- range .RefKeys }}
        {{- " " }}obj.{{$fb.Field}} = obj{{$fb.ID}}.{{.Ref.Field}}
      {{- end}}
      {{- ")" }}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "ScanFieldDef" }}
  {{- $idx:=0}}{{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range .RefKeys}}
        {{- if gt $idx 0}}{{"\n  "}}{{end}}{{$idx = add $idx 1}}var ref{{$fb.ID}}_{{.Ref.ID}} {{.Ref.GoSqlNullType }}
      {{- end}}
      {{- range .RefFields}}
        {{- if gt $idx 0}}{{"\n  "}}{{end}}{{$idx = add $idx 1}}var ref{{$fb.ID}}_{{.Ref.ID}} {{.Ref.GoSqlNullType}}
      {{- end}}
    {{- end}}
  {{- end}}
{{- end}}

{{- define "ScanField" }}
  {{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range .RefKeys }}
        &ref{{$fb.ID}}_{{.Ref.ID}},
      {{- end}}
      {{- range .RefFields }}
        &ref{{$fb.ID}}_{{.Ref.ID}},
      {{- end}}
    {{- else if eq .Type "many-to-many" }}
    {{-  else }}
      &obj.{{.ID}},
    {{- end}}
  {{- end}}
{{- end}}

{{- define "ScanFieldRef" -}}
  {{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" }}{{$fb := . }}
      {{- range .RefKeys }}
        if ref{{$fb.ID}}_{{.Ref.ID}}.Valid {
          if obj.{{$fb.ID}} == nil {
        	  obj.{{$fb.ID}} = &User{ {{.Ref.ID}}: ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue}}}
          } else {
        	  obj.{{$fb.ID}}.{{.Ref.ID}} = ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue}}
          }
        }
      {{- end}}
      {{- range .RefFields }}
        if ref{{$fb.ID}}_{{.Ref.ID}}.Valid {
          obj.{{$fb.ID}}.{{.Ref.ID}} = ref{{$fb.ID}}_{{.Ref.ID}}.{{.Ref.GoSqlNullValue}}
        }
      {{- end}}
    {{- end}}
  {{- end}}
{{- end}}

{{define "FilterOp" -}}
  {{- $m := .m -}}
  {{- $res := .Res -}}
  for _, f := range filter {
    switch f.Field {
    {{range .m.Fields -}}{{if eq .Type "text" -}}
    case {{$m.ID}}Field_{{.ID}}:
      switch f.Op {
      case FilterOp_EQ:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} = {{ template "QryParamArg" .}})
      case FilterOp_Like:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} LIKE {{ template "QryParamArg" .}})
      case FilterOp_ILike:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} ILIKE {{ template "QryParamArg" .}})
      default:
        return {{$res}}fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
      }
    {{end}}{{end -}}
    default:
      return {{$res}}fmt.Errorf("unsupported filter field %v", f.Field)
    }
  }
{{- end -}}

{{define "QueryFindCount" -}}
  SELECT COUNT(
  {{- $idx := 0}}{{range .PKeys -}}{{- if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}obj.{{.Field -}}
  {{- end}}) FROM {{.Table}} obj
{{- end -}}

{{define "CreateReturning" -}}
{{- end -}}

{{define "CreateExec" -}}
  res, err := tx.ExecContext(ctx, qry,
   {{- range .Fields -}}{{$f := . -}}
      {{- if eq .Type "autoincrement" -}}
      {{- else if eq .Type "many-to-many" }}
      {{- else if eq .Type "many-to-one" }}
        {{- range .RefKeys}}
          {{- "\n    "}}obj{{$f.ID}}_{{.Ref.ID}},
        {{- end}}
      {{- else if eq .Type "password" }}
        {{- "\n    "}}obj_{{.ID}},
      {{- else }}
        {{- "\n    "}}obj.{{.ID}},
      {{- end}}
    {{- end}}
  )
  if err != nil {
		slog.Error("Insert", "qry:", qry, "Error:", err)
    return nil, err
  }
	ra, err := res.RowsAffected()
	if err != nil {
		return nil, err
	}
	if ra != 1 {
		return nil, fmt.Errorf("ERR_INSERT_FAILED")
	}
	obj.ID, err = res.LastInsertId()
  if err != nil {
    return nil, err
  }
{{- end -}}

{{ define "QryParam" -}}
  ${{ . }}
{{- end -}}

{{ define "QryParamArg" -}}
  $%d", len(args))
{{- end -}}

{{ define "StoreImpl" -}}
func (r *{{.ID}}StoreImpl) Create(ctx context.Context, obj {{.ID}}) (*{{.ID}}, error) {
  var tx *sql.Tx
  var err error
  var txNew bool
  tx, err = r.db.BeginTx(ctx, nil)
  txNew = true
  defer tx.Rollback()
  {{- range .Fields -}}
    {{- if eq .Type "version" -}}
      {{- "\n  "}}obj.{{.ID}} = 1
    {{- end}}
  {{- end}}
  {{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-one" -}}
      {{- range .RefKeys}}
        {{- "\n  "}}var obj{{$f.ID}}_{{.Ref.ID}} {{ .Ref.GoSqlNullType }}
        {{- "\n  "}}if obj.{{$f.ID}} != nil {
        {{- "\n    "}}obj{{$f.ID}}_{{.Ref.ID}} = {{ .Ref.GoSqlNullType }}{ {{ .Ref.GoSqlNullValue }}:obj.{{$f.ID}}.{{.Ref.ID}}, Valid:true }
        {{- "\n  "}}} else {
        {{- "\n    "}}obj{{$f.ID}}_{{.Ref.ID}} = {{ .Ref.GoSqlNullType }}{ Valid: false }
        {{- "\n  "}}}
      {{- end}}
    {{- else if eq .Type "password" }}
      obj_{{.ID}}, err := HashPassword(obj.{{.ID}})
      if err != nil {
        return nil, err
      }
    {{- end}}
  {{- end}}
  qry := `
    INSERT INTO {{.Table}} (
      {{ $idx := 0 }}{{- range .Fields }}
        {{- if eq .Type "autoincrement" -}}
        {{- else if eq .Type "many-to-many" }}
        {{- else if eq .Type "many-to-one" }}{{$fb := . }}
          {{- range .RefKeys}}
            {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}{{.Field}}
          {{- end}}
        {{- else }}
          {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}{{.Field}}
        {{- end}}
      {{- end}}
    ) VALUES (
      {{ $idx := 0 }}{{- range .Fields }}
        {{- if eq .Type "autoincrement" -}}
        {{- else if eq .Type "many-to-many" }}
        {{- else if eq .Type "many-to-one" }}{{$fb := . }}
          {{- range .RefKeys}}
            {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}{{template "QryParam" $idx}}
          {{- end}}
        {{- else }}
          {{- if gt $idx 0}},{{ "\n      " }}{{end}}{{ $idx = add $idx 1 }}{{template "QryParam" $idx}}
        {{- end}}
      {{- end}}
    ){{ template "CreateReturning" . }}`
  {{template "CreateExec" .}}
  {{- range .Fields -}}{{$f := . -}}
    {{- if eq .Type "many-to-many" }}
  qry = `
    INSERT INTO {{.MapTable}} (
      {{- $fidx := 0}}{{range .MapKeys}}
        {{- if gt $fidx 0}}, {{end}}{{$fidx = add $fidx 1}}
        {{- .Field}}
      {{- end}}
      {{- range .RefKeys}}
        {{- if gt $fidx 0}}, {{end}}{{$fidx = add $fidx 1}}
        {{- .Field}}
      {{- end}})
    VALUES (
      {{- $fidx := 0}}{{range .MapKeys}}
        {{- if gt $fidx 0}}, {{end}}{{$fidx = add $fidx 1}}
        {{ template "QryParam" $fidx}}
      {{- end}}
      {{- range .RefKeys}}
        {{- if gt $fidx 0}}, {{end}}{{$fidx = add $fidx 1}}
        {{ template "QryParam" $fidx}}
      {{- end}})`
    for _, objRef := range obj.{{$f.ID}} {
      res, err := tx.ExecContext(ctx, qry
        {{- range .MapKeys}}
          {{- ", obj." }}{{- .Ref.ID}}
        {{- end}}
        {{- range .RefKeys}}
          {{- ", objRef." }}{{- .Ref.ID}}
        {{- end}})
      if err != nil {
		    slog.Error("Insert {{.MapTable}}", "qry:", qry, "Error:", err)
        return nil, err
      }
    	ra, err := res.RowsAffected()
    	if err != nil {
    		return nil, err
    	}
    	if ra != 1 {
    		return nil, fmt.Errorf("ERR_INSERT_FAILED")
    	}
    }
    {{- end}}
  {{- end}}
  if txNew {
    err = tx.Commit()
    if err != nil {
      return nil, err
    }
  }
  return &obj, nil
}

func (r *{{.ID}}StoreImpl) Get(ctx context.Context, {{template "ParamFk" . }}) (*{{.ID}}, error) {
  qry := `
    SELECT
      {{ template "GetSelectField" . }}
    FROM
      {{template "GetSelectFrom" . }}
    WHERE
      {{ template "WhereFk" . }}`
  var obj {{.ID}};
  {{template "GetScanFieldDef" .}}
  rows, err := r.db.QueryContext(ctx, qry, {{ template "ArgFk" . }})
  if err != nil {
		slog.Error("Query", "qry:", qry, "Error:", err)
		return nil, err
	}
	if rows.Next() {
		err = rows.Scan(
      {{- template "GetScanField" . }}
    )
    if err != nil {
      return nil, err
    }
    {{- template "GetScanFieldRef" .}}
    {{- template "GetScanFieldManyRef" .}}
    for rows.Next() {
  		err = rows.Scan(
        {{- template "GetScanField" . }}
      )
      if err != nil {
        return nil, err
      }
      {{- template "GetScanFieldManyRef" .}}
    }
  }
  return &obj, nil
}

{{range .Uniques -}}
func (r *{{.Model.ID}}StoreImpl) GetBy{{.ID}}(ctx context.Context, {{template "ParamUnique" . }}) (*{{.Model.ID}}, error) {
  qry := `
    SELECT
      {{ template "GetSelectField" .Model }}
    FROM
      {{template "GetSelectFrom" .Model }}
    WHERE
      {{ template "WhereUnique" . }}`
  var obj {{.Model.ID}};
  {{template "GetScanFieldDef" .Model}}
  rows, err := r.db.QueryContext(ctx, qry, {{ template "ArgUnique" . }})
  if err != nil {
    return nil, err
  }
  {{- template "GetScanFieldRef" .Model}}
  {{- template "GetScanFieldManyRef" .Model}}
  for rows.Next() {
		err = rows.Scan(
      {{- template "GetScanField" .Model}}
    )
    if err != nil {
      return nil, err
    }
    {{- template "GetScanFieldManyRef" .Model}}
  }
  return &obj, nil
}
{{- end}}

func (r *{{.ID}}StoreImpl) FindOne(ctx context.Context, filter []{{.ID}}Filter, sorting []{{.ID}}Sorting) (*{{.ID}}, error) {
  qfilter := []string{}
  args := []any{}
  {{template "FilterOp" (dict "m" . "Res" "nil, " )}}
  qry := `
    SELECT
      {{ template "SelectField" . }}
    FROM
      {{template "SelectFrom" . }}`
  if len(qfilter) > 0 {
    qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
  }
  if len(sorting) > 0 {
    sorts := []string{}
    for _, f := range sorting {
      switch f.Field {
      {{range .Fields }}{{if eq .Type "text" -}}
      case {{.Model.ID}}Field_{{.ID}}:
        if f.Dir == SortDir_ASC {
          sorts = append(sorts, "obj.{{.Field}} ASC")
        } else {
          sorts = append(sorts, "obj.{{.Field}} DESC")
        }
      {{end}}{{end}}}
    }
    if len(sorts) > 0 {
      qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  qry += "\n  LIMIT 1"
  rows, err := r.db.QueryContext(ctx, qry, args...)
  if err != nil {
    slog.Error("Query list", "qry:", qry, "Error:", err)
    return nil, err
  }
  if rows.Next() {
    var obj {{.ID}};
    {{template "ScanFieldDef" .}}
    err = rows.Scan(
      {{- template "ScanField" . }}
    )
    if err != nil {
      return nil, err
    }
    {{- template "ScanFieldRef" .}}
    return &obj, nil
  }
  return nil, fmt.Errorf("not found")
}

func (r *{{.ID}}StoreImpl) Find(ctx context.Context, filter []{{.ID}}Filter, sorting []{{.ID}}Sorting, limit int, offset int64) ([]{{.ID}}, int64, error) {
  qfilter := []string{}
  args := []any{}
  {{template "FilterOp" (dict "m" . "Res" "nil, 0, " )}}
  qry := `{{template "QueryFindCount" .}}`
  if len(qfilter) > 0 {
    qry += " WHERE " + strings.Join(qfilter, " AND ")
  }
  total := int64(0)
  err := r.db.QueryRowContext(ctx, qry, args...).Scan(&total)
  if err != nil {
    slog.Error("Query count", "qry:", qry, "Error:", err)
    return nil, 0, err
  }
  qry = `SELECT
      {{ template "SelectField" . }}
    FROM
      {{template "SelectFrom" . }}`
  if len(qfilter) > 0 {
    qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
  }
  if len(sorting) > 0 {
    sorts := []string{}
    for _, f := range sorting {
      switch f.Field {
      {{range .Fields }}{{if eq .Type "text" -}}
      case {{.Model.ID}}Field_{{.ID}}:
        if f.Dir == SortDir_ASC {
          sorts = append(sorts, "obj.{{.Field}} ASC")
        } else {
          sorts = append(sorts, "obj.{{.Field}} DESC")
        }
      {{end}}{{end}}}
    }
    if len(sorts) > 0 {
      qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  qry += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
  rows, err := r.db.QueryContext(ctx, qry, args...)
  if err != nil {
    slog.Error("Query list", "qry:", qry, "Error:", err)
    return nil, 0, err
  }
  list := []{{.ID}}{};
  for rows.Next() {
    var obj {{.ID}};
    {{template "ScanFieldDef" .}}
    err = rows.Scan(
      {{- template "ScanField" . }}
    )
    if err != nil {
      return nil, total, err
    }
    {{- template "ScanFieldRef" .}}
    list = append(list, obj)
  }
  return list, total, nil
}

func (r *{{.ID}}StoreImpl) Update(ctx context.Context, obj {{.ID}}, fields []{{.ID}}Field) error {
  var tx *sql.Tx
  var err error
  var txNew bool
  tx, err = r.db.BeginTx(ctx, nil)
  if err != nil {
    return err
  }
  txNew = true
  defer tx.Rollback()
  args := []any{}
  qry := `UPDATE {{.Table}} SET`
  {{- range .Fields -}}
    {{- if eq .Type "version" -}}
      {{- "\n  "}}if len(args) > 0 { qry += "," }
      {{- "\n  "}}args = append(args, obj.{{.ID}} + 1)
      {{- "\n  "}}qry += fmt.Sprintf("  {{.Field}} = {{ template "QryParamArg" . }}
    {{- end}}
  {{- end}}
  for _, f := range fields {
    switch f {
    {{- range .Fields}}{{if .IsUpdatable }}
    {{- if eq .Type "many-to-one" }}
      case {{.Model.ID}}Field_{{.ID}}:
        {{- $f := .}}{{range .RefKeys}}
        if len(args) > 0 { qry += "," }
        args = append(args, obj.{{$f.ID}}.{{.ID}})
        qry += fmt.Sprintf("  {{.Field}} = {{ template "QryParamArg" . }}
        {{- end}}
    {{- else if eq .Type "many-to-many" }}
    {{- else }}
      case {{.Model.ID}}Field_{{.ID}}:
        if len(args) > 0 { qry += "," }
        args = append(args, obj.{{.ID}})
        qry += fmt.Sprintf("  {{.Field}} = {{ template "QryParamArg" . }}
    {{- end}}{{end}}{{end}}
    default:
      return fmt.Errorf("field %v is unknown", f)
    }
  }
  qry += "\nWHERE\n"
  {{$idx := 0}}{{ range .Fields -}}{{if .IsPk -}}
    args = append(args, obj.{{.ID}})
    qry += fmt.Sprintf("{{if gt $idx 0}} AND\n{{end}}  {{.Field}} = {{ template "QryParamArg" . }}{{$idx = add $idx 1}}
  {{- end}}{{- end}}
  {{ range .Fields -}}{{if eq .Type "version" -}}
    args = append(args, obj.{{.ID}})
    qry += fmt.Sprintf("{{if gt $idx 0}} AND\n{{end}}  {{.Field}} = {{ template "QryParamArg" . }}{{$idx = add $idx 1}}
  {{- end}}{{- end}}
  res, err := tx.ExecContext(ctx, qry, args...)
  if err != nil {
    slog.Error("Update", "qry:", qry, "Error:", err)
    return err
  }
  ra, err := res.RowsAffected()
  if err != nil {
    slog.Error("Update", "qry:", qry, "args:", args, "Error:", err)
    return err
  }
  if ra == 0 {
    return fmt.Errorf("no rows affected")
  }
  if ra != 1 {
    return fmt.Errorf("invalid rows affected (%d)", ra)
  }
  if txNew {
    err = tx.Commit()
    if err != nil {
      return err
    }
  }
  return nil
}

{{- range .Fields}}{{if eq .Type "password"}}
func (r *{{.Model.ID}}StoreImpl) Update{{.ID}}(ctx context.Context, {{template "ParamFkVersion" .Model }}, value string) error {
  var tx *sql.Tx
  var err error
  var txNew bool
  tx, err = r.db.BeginTx(ctx, nil)
  if err != nil {
    return err
  }
  txNew = true
  defer tx.Rollback()
  args := []any{}
  password, err := HashPassword(value)
  if err != nil {
    return err
  }
  qry := `UPDATE {{.Model.Table}} SET `
  {{- range .Model.Fields }}{{if eq .Type "password" }}
    if len(args) > 0 { qry += ", " }
    args = append(args, password)
    qry += fmt.Sprintf("{{.Field}} = {{ template "QryParamArg" . }}
  {{- end}}{{- end}}
  qry += ` WHERE `
  {{$idx := 0}}{{ range .Model.Fields -}}{{if .IsPk -}}
    args = append(args, {{.Field}})
    qry += fmt.Sprintf("{{if gt $idx 0}} AND\n{{end}}  {{.Field}} = {{ template "QryParamArg" . }}{{$idx = add $idx 1}}
  {{- end}}{{- end}}
  {{ range .Model.Fields -}}{{if eq .Type "version" -}}
    args = append(args, {{.Field}})
    qry += fmt.Sprintf("{{if gt $idx 0}} AND\n{{end}}  {{.Field}} = {{ template "QryParamArg" . }}{{$idx = add $idx 1}}
  {{- end}}{{- end}}
  res, err := tx.ExecContext(ctx, qry, args...)
  if err != nil {
    slog.Error("Update", "qry:", qry, "Error:", err)
    return err
  }
  ra, err := res.RowsAffected()
  if err != nil {
    slog.Error("Update", "qry:", qry, "args:", args, "Error:", err)
    return err
  }
  if ra == 0 {
    return fmt.Errorf("no rows affected")
  }
  if ra != 1 {
    return fmt.Errorf("invalid rows affected (%d)", ra)
  }
  if txNew {
    err = tx.Commit()
    if err != nil {
      return err
    }
  }
  return nil
}
{{- end}}{{end}}

func (r *{{.ID}}StoreImpl) Delete(ctx context.Context, {{template "ParamFk" . }}) error {
  var tx *sql.Tx
  var err error
  var txNew bool
  tx, err = r.db.BeginTx(ctx, nil)
  if err != nil {
    return err
  }
  txNew = true
  qry := `
    DELETE FROM {{.Table}} WHERE
      {{ template "WhereFk" . }}`
  res, err := tx.ExecContext(ctx, qry, {{ template "ArgFk" .}})
  if err != nil {
    return err
  }
  ra, err := res.RowsAffected()
  if err != nil {
    return err
  }
  if ra == 0 {
    return fmt.Errorf("no rows affected")
  }
  if ra != 1 {
    return fmt.Errorf("invalid rows affected (%d)", ra)
  }
  if txNew {
    err = tx.Commit()
    if err != nil {
      return err
    }
  }
  return nil
}
{{ end -}}
