// FILE: handler/gen__{{snakeCase .ID}}.go
// Code generated by apigen. DO NOT EDIT.
// GENERATED: {{now}}

package handler

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strconv"

  "{{.Module}}/model"
)

{{- define "PathFk" -}}
  {{ $idx := 0}}{{range .PKeys -}}
    {{- "/{"}}{{.Name}}{{"}" -}}
  {{- end}}
{{- end }}

// swagger: model {{.ID}}FindParam
type {{.ID}}FindParam struct {
  Limit   int                    `json:"limit"`
  Offset  int64                  `json:"offset"`
	Filter  []model.{{.ID}}Filter  `json:"filter"`
	Sorting []model.{{.ID}}Sorting `json:"sorting"`
}

// swagger: model {{.ID}}UpdateParam
type {{.ID}}UpdateParam struct {
  Value model.{{.ID}}         `json:"value"`
  Fields []model.{{.ID}}Field `json:"fields"`
}

func {{.ID}}HandlerRegister(mux *http.ServeMux, store model.Store, authenticate Authenticate) {
  mux.HandleFunc("PUT /{{snakeCase .ID}}", func(w http.ResponseWriter, r *http.Request) {
    if !authenticate(r, "{{.Table}}", "create") {
		  writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Create(r.Context(), store, w, r); err != nil {
			slog.Warn("error in {{.ID}}Create", "err", err)
      writeError(w, http.StatusInternalServerError, err)
    }
  })
  mux.HandleFunc("GET /{{snakeCase .ID}}{{ template "PathFk" . }}", func(w http.ResponseWriter, r *http.Request) {
    if !authenticate(r, "{{.Table}}", "read") {
		  writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Get(r.Context(), store, w, r); err != nil {
			slog.Warn("error in {{.ID}}Get", "err", err)
      writeError(w, http.StatusInternalServerError, err)
    }
  })
  mux.HandleFunc("POST /{{snakeCase .ID}}", func(w http.ResponseWriter, r *http.Request) {
    if !authenticate(r, "{{.Table}}", "read") {
		  writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Find(r.Context(), store, w, r); err != nil {
			slog.Warn("error in {{.ID}}Find", "err", err)
      writeError(w, http.StatusInternalServerError, err)
    }
  })
  mux.HandleFunc("PATCH /{{snakeCase .ID}}{{ template "PathFk" . }}", func(w http.ResponseWriter, r *http.Request) {
    if !authenticate(r, "{{.Table}}", "update") {
		  writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Update(r.Context(), store, w, r); err != nil {
			slog.Warn("error in {{.ID}}Update", "err", err)
      writeError(w, http.StatusInternalServerError, err)
    }
  })
  mux.HandleFunc("DELETE /{{snakeCase .ID}}{{ template "PathFk" . }}", func(w http.ResponseWriter, r *http.Request) {
    if !authenticate(r, "{{.Table}}", "delete") {
		  writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Delete(r.Context(), store, w, r); err != nil {
			slog.Warn("error in {{.ID}}Delete", "err", err)
      writeError(w, http.StatusInternalServerError, err)
    }
  })
}

// Create{{.ID}}   godoc
// @Summary      Create {{snakeCase .ID}}
// @Description  Create {{snakeCase .ID}}
// @Tags         {{snakeCase .ID}}
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        {{snakeCase .ID}}  body    model.{{.ID}}  true  "{{.ID}} object"
// @Success      200  {object}  model.{{.ID}}
// @Failure      400  {object}  HttpResult
// @Failure      404  {object}  HttpResult
// @Failure      500  {object}  HttpResult
// @Router       /{{snakeCase .ID}} [put]
func {{.ID}}Create(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
  var obj model.{{.ID}}
  err := json.NewDecoder(r.Body).Decode(&obj)
  if err != nil {
    slog.Warn("invalid body", "err", err)
    return fmt.Errorf("invalid body")
  }
  {{range .Fields -}}
    {{if eq .ID "CreatedBy" "UpdatedBy" -}}{{if eq .Type "many-to-one" -}}
    	if user, ok := ctx.Value(HandlerCtxKeyUser).(*LoginUser); ok && user.User != nil {
    		obj.{{.ID}} = &model.UserRef{
          {{- range .Model.PKeys }}
      	    {{.ID}}: user.User.{{.ID}},
          {{- end}}
        }
    	} else {
    		return fmt.Errorf("missing user in context")
    	}
    {{end}}{{else if eq .ID "CreatedAt" "UpdatedAt" -}}
      obj.{{.ID}} = time.Now()
    {{end -}}
  {{- end}}
  res, err := store.{{.ID}}().Create(ctx, obj)
  if err != nil {
    slog.Warn("error create {{.ID}}", "obj", obj, "err", err)
    return err
  }
	return json.NewEncoder(w).Encode(res)
}

// Show{{.ID}}   godoc
// @Summary      Get {{snakeCase .ID}} By PK
// @Description  Get {{snakeCase .ID}} By PK
// @Tags         {{snakeCase .ID}}
// @Accept       json
// @Produce      json
// @Security     BearerAuth
{{- range .PKeys }}
// @Param        {{.Name}}   path      {{.GoJsonType}}  true  "{{.Model.ID}} {{.ID}}"
{{- end}}
// @Success      200  {object}  model.{{.ID}}
// @Failure      400  {object}  HttpResult
// @Failure      404  {object}  HttpResult
// @Failure      500  {object}  HttpResult
// @Router       /{{snakeCase .ID}}
{{- range .PKeys -}}
/{ {{- .Name -}} }
{{- end}} [get]
func {{.ID}}Get(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
  {{- range .PKeys -}}
    {{- if eq .Type "autoincrement" "integer"}}
      p{{.Name}} := r.PathValue("{{.Name}}")
  	  {{.Name}}, err := strconv.ParseInt(p{{.Name}}, 10, 64)
    	if err != nil {
    		slog.Warn("invalid {{.Name}}", "{{.Name}}", p{{.Name}}, "err", err)
    		return fmt.Errorf("invalid {{.Name}}")
    	}
    {{- else}}
      {{.Name}} := r.PathValue("{{.Name}}")
    {{- end}}
  {{- end}}
	obj, err := store.{{.ID}}().Get(ctx
  {{- range .PKeys -}}
    {{- ", "}}{{.Name -}}
  {{- end}})
	if err != nil {
		slog.Warn("error get {{.ID}}"
    {{- range .PKeys -}}
      {{- ", "}}"{{.Name -}}", {{.Name -}}
    {{- end -}}
    , "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(obj)
}

// Find{{.ID}}   godoc
// @Summary      Find {{snakeCase .ID}}
// @Description  get string by ID
// @Tags         {{snakeCase .ID}}
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        param  body    {{.ID}}FindParam  true  "{{.ID}} object"
// @Success      200  {object}  model.{{.ID}}
// @Failure      400  {object}  HttpResult
// @Failure      404  {object}  HttpResult
// @Failure      500  {object}  HttpResult
// @Router       /{{snakeCase .ID}} [post]
func {{.ID}}Find(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
	var obj {{.ID}}FindParam
  err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		slog.Warn("invalid body", "err", err)
		return fmt.Errorf("invalid body")
	}
	var result struct {
		List  []model.{{.ID}} `json:"list"`
		Total int64        `json:"total"`
	}
	result.List, result.Total, err = store.{{.ID}}().Find(ctx, obj.Filter, obj.Sorting, obj.Limit, obj.Offset)
	if err != nil {
		slog.Warn("error find {{.ID}}", "filter", obj.Filter, "sorting", obj.Sorting, "limit", obj.Limit, "offset", obj.Offset, "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(result)
}

// Update{{.ID}}   godoc
// @Summary      Update {{snakeCase .ID}}
// @Description  Update {{snakeCase .ID}}
// @Tags         {{snakeCase .ID}}
// @Accept       json
// @Produce      json
// @Security     BearerAuth
{{- range .PKeys }}
// @Param        {{.Name}}   path      {{.GoJsonType}}  true  "{{.Model.ID}} {{.ID}}"
{{- end}}
// @Param        param  body    {{.ID}}UpdateParam  true  "{{.ID}} object"
// @Success      200  {object}  model.{{.ID}}
// @Failure      400  {object}  HttpResult
// @Failure      404  {object}  HttpResult
// @Failure      500  {object}  HttpResult
// @Router       /{{snakeCase .ID}}
{{- range .PKeys -}}
/{ {{- .Name -}} }
{{- end}} [patch]
func {{.ID}}Update(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
  var obj {{.ID}}UpdateParam
  err := json.NewDecoder(r.Body).Decode(&obj)
  if err != nil {
    slog.Warn("invalid body", "err", err)
    return fmt.Errorf("invalid body")
  }
  {{range .Fields -}}
    {{if eq .ID "UpdatedBy" -}}{{if eq .Type "many-to-one" -}}
    	if user, ok := ctx.Value(HandlerCtxKeyUser).(*LoginUser); ok && user.User != nil {
     		obj.Value.{{.ID}} = &model.UserRef{
          {{- range .Model.PKeys }}
      	    {{.ID}}: user.User.{{.ID}},
          {{- end}}
        }
    		obj.Fields = append(obj.Fields, model.UserField_{{.ID}})
    	} else {
    		return fmt.Errorf("missing user in context")
    	}
    {{end}}{{else if eq .ID "UpdatedAt" -}}
      obj.Value.{{.ID}} = time.Now()
      obj.Fields = append(obj.Fields, model.{{.Model.ID}}Field_{{.ID}})
    {{end -}}
  {{- end}}
  {{- range .PKeys -}}
    {{- if eq .Type "autoincrement" "integer"}}
      p{{.Name}} := r.PathValue("{{.Name}}")
  	  {{.Name}}, err := strconv.ParseInt(p{{.Name}}, 10, 64)
    	if err != nil {
    		slog.Warn("invalid {{.Name}}", "{{.Name}}", p{{.Name}}, "err", err)
    		return fmt.Errorf("invalid {{.Name}}")
    	}
      obj.Value.{{.ID}} = {{.Name}}
    {{- else}}
      obj.Value.{{.ID}} = r.PathValue("{{.Name}}")
    {{- end}}
  {{- end}}
  err = store.{{.ID}}().Update(ctx, obj.Value, obj.Fields)
  if err != nil {
    slog.Warn("error update {{.ID}}", "obj", obj, "err", err)
    return err
  }
	return json.NewEncoder(w).Encode(obj.Value)
}

// Delete{{.ID}}   godoc
// @Summary      Delete {{snakeCase .ID}}
// @Description  Delete
// @Tags         {{snakeCase .ID}}
// @Accept       json
// @Produce      json
// @Security     BearerAuth
{{- range .PKeys }}
// @Param        {{.Name}}   path      {{.GoJsonType}}  true  "{{.Model.ID}} {{.ID}}"
{{- end}}
// @Success      200  {object}  any
// @Failure      400  {object}  HttpResult
// @Failure      404  {object}  HttpResult
// @Failure      500  {object}  HttpResult
// @Router       /{{snakeCase .ID}}
{{- range .PKeys -}}
/{ {{- .Name -}} }
{{- end}} [delete]
func {{.ID}}Delete(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
  var err error
  {{- range .PKeys -}}
    {{- if eq .Type "autoincrement" "integer"}}
      p{{.Name}} := r.PathValue("{{.Name}}")
  	  {{.Name}}, err := strconv.ParseInt(p{{.Name}}, 10, 64)
    	if err != nil {
    		slog.Warn("invalid {{.Name}}", "{{.Name}}", p{{.Name}}, "err", err)
    		return fmt.Errorf("invalid {{.Name}}")
    	}
    {{- else}}
      {{.Name}} := r.PathValue("{{.Name}}")
    {{- end}}
  {{- end}}
	err = store.{{.ID}}().Delete(ctx
  {{- range .PKeys -}}
    {{- ", "}}{{.Name -}}
  {{- end}})
	if err != nil {
		slog.Warn("error get {{.ID}}"
    {{- range .PKeys -}}
      {{- ", "}}"{{.Name -}}", {{.Name -}}
    {{- end -}}
    , "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}
