// FILE: handler/{{snakeCase .ID}}.go
// Code generated by apigen. DO NOT EDIT.
// GENERATED: {{now}}

package handler

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strconv"

  "{{.Module}}/model"
)

{{- define "PathFk" -}}
  {{ $idx := 0}}{{range .PKeys -}}
    {{- "/{"}}{{.Field}}{{"}" -}}
  {{- end}}
{{- end }}

func {{.ID}}HandlerRegister(mux *http.ServeMux, store model.Store, access AccessPermission) {
  mux.HandleFunc("PUT /{{.ID}}", func(w http.ResponseWriter, r *http.Request) {
    if !access(r, AccessActionCreate) {
      writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Create(r.Context(), store, w, r); err != nil {
      writeError(w, http.StatusInternalServerError, err)
    }
  })
  mux.HandleFunc("GET /{{.ID}}{{ template "PathFk" . }}", func(w http.ResponseWriter, r *http.Request) {
    if !access(r, AccessActionRead) {
      writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Get(r.Context(), store, w, r); err != nil {
      writeError(w, http.StatusInternalServerError, err)
    }
  })
  mux.HandleFunc("POST /{{.ID}}", func(w http.ResponseWriter, r *http.Request) {
    if !access(r, AccessActionRead) {
      writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Find(r.Context(), store, w, r); err != nil {
      writeError(w, http.StatusInternalServerError, err)
    }
  })
  mux.HandleFunc("PATCH /{{.ID}}{{ template "PathFk" . }}", func(w http.ResponseWriter, r *http.Request) {
    if !access(r, AccessActionUpdate) {
      writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Update(r.Context(), store, w, r); err != nil {
      writeError(w, http.StatusInternalServerError, err)
    }
  })
  mux.HandleFunc("DELETE /{{.ID}}{{ template "PathFk" . }}", func(w http.ResponseWriter, r *http.Request) {
    if !access(r, AccessActionDelete) {
      writeError(w, http.StatusForbidden, fmt.Errorf("forbidden"))
      return
    }
    if err := {{.ID}}Delete(r.Context(), store, w, r); err != nil {
      writeError(w, http.StatusInternalServerError, err)
    }
  })
}

func {{.ID}}Create(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
  var obj model.{{.ID}}
  err := json.NewDecoder(r.Body).Decode(&obj)
  if err != nil {
    slog.Warn("invalid body", "err", err)
    return fmt.Errorf("invalid body")
  }
  {{range .Fields -}}
    {{if eq .ID "CreatedBy" "UpdatedBy" -}}
      if user, ok := ctx.Value(HandlerCtxKeyUser).(*model.User); ok {
        obj.{{.ID}} = user
      } else {
        return fmt.Errorf("missing user in context")
      }
    {{else if eq .ID "CreatedAt" "UpdatedAt" -}}
      obj.{{.ID}} = time.Now()
    {{end -}}
  {{- end}}
  res, err := store.{{.ID}}().Create(ctx, obj)
  if err != nil {
    slog.Warn("error create {{.ID}}", "obj", obj, "err", err)
    return err
  }
	return json.NewEncoder(w).Encode(res)
}

func {{.ID}}Get(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
  {{range .PKeys -}}
    p{{.Field}} := r.PathValue("{{.Field}}")
  	{{.Field}}, err := strconv.ParseInt(p{{.Field}}, 10, 64)
  	if err != nil {
  		slog.Warn("invalid {{.Field}}", "{{.Field}}", p{{.Field}}, "err", err)
  		return fmt.Errorf("invalid {{.Field}}")
  	}
  {{- end}}
	obj, err := store.{{.ID}}().Get(ctx
  {{- range .PKeys -}}
    {{- ", "}}{{.Field -}}
  {{- end}})
	if err != nil {
		slog.Warn("error get {{.ID}}"
    {{- range .PKeys -}}
      {{- ", "}}"{{.Field -}}", {{.Field -}}
    {{- end -}}
    , "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(obj)
}

func {{.ID}}Find(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
	var obj struct {
    Limit   int                    `json:"limit"`
    Offset  int64                  `json:"offset"`
		Filter  []model.{{.ID}}Filter  `json:"filter"`
		Sorting []model.{{.ID}}Sorting `json:"sorting"`
	}
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		slog.Warn("invalid body", "err", err)
		return fmt.Errorf("invalid body")
	}
	var result struct {
		List  []model.{{.ID}} `json:"list"`
		Total int64        `json:"total"`
	}
	result.List, result.Total, err = store.{{.ID}}().Find(ctx, obj.Filter, obj.Sorting, obj.Limit, obj.Offset)
	if err != nil {
		slog.Warn("error find {{.ID}}", "filter", obj.Filter, "sorting", obj.Sorting, "limit", obj.Limit, "offset", obj.Offset, "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(result)
}

func {{.ID}}Update(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
  var obj struct {
    Value model.{{.ID}} `json:"value"`
    Fields []model.{{.ID}}Field `json:"fields"`
  }
  err := json.NewDecoder(r.Body).Decode(&obj)
  if err != nil {
    slog.Warn("invalid body", "err", err)
    return fmt.Errorf("invalid body")
  }
  {{range .Fields -}}
    {{if eq .ID "UpdatedBy" -}}
      if user, ok := ctx.Value(HandlerCtxKeyUser).(*model.User); ok {
        obj.Value.{{.ID}} = user
        obj.Fields = append(obj.Fields, model.{{.Model.ID}}Field_{{.ID}})
      } else {
        return fmt.Errorf("missing user in context")
      }
    {{else if eq .ID "UpdatedAt" -}}
      obj.Value.{{.ID}} = time.Now()
      obj.Fields = append(obj.Fields, model.{{.Model.ID}}Field_{{.ID}})
    {{end -}}
  {{- end}}
  {{range .PKeys -}}
    p{{.Field}} := r.PathValue("{{.Field}}")
  	{{.Field}}, err := strconv.ParseInt(p{{.Field}}, 10, 64)
  	if err != nil {
  		slog.Warn("invalid {{.Field}}", "{{.Field}}", p{{.Field}}, "err", err)
  		return fmt.Errorf("invalid {{.Field}}")
  	}
    obj.Value.{{.ID}} = {{.Field}}
  {{- end}}
  err = store.{{.ID}}().Update(ctx, obj.Value, obj.Fields)
  if err != nil {
    slog.Warn("error update {{.ID}}", "obj", obj, "err", err)
    return err
  }
	return json.NewEncoder(w).Encode(obj.Value)
}

func {{.ID}}Delete(ctx context.Context, store model.Store, w http.ResponseWriter, r *http.Request) error {
  {{range .PKeys -}}
    p{{.Field}} := r.PathValue("{{.Field}}")
  	{{.Field}}, err := strconv.ParseInt(p{{.Field}}, 10, 64)
  	if err != nil {
  		slog.Warn("invalid {{.Field}}", "{{.Field}}", p{{.Field}}, "err", err)
  		return fmt.Errorf("invalid {{.Field}}")
  	}
  {{- end}}
	err = store.{{.ID}}().Delete(ctx
  {{- range .PKeys -}}
    {{- ", "}}{{.Field -}}
  {{- end}})
	if err != nil {
		slog.Warn("error get {{.ID}}"
    {{- range .PKeys -}}
      {{- ", "}}"{{.Field -}}", {{.Field -}}
    {{- end -}}
    , "err", err)
		return err
	}
	return json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}
