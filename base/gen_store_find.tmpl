{{ define "StoreImplFind" -}}
// FILE-b2bab6a74adbe2e8dd47ebdcb76db7c4: model/gen__{{snakeCase .ID}}_store_find.go
// Code generated by apigen. DO NOT EDIT.
// GENERATED: {{now}}

package {{.Package}}

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log/slog"
	"strings"
	"{{.Module}}/util/jsql"
)

func (r *{{.ID}}StoreImpl) FindOne(ctx context.Context, filter []{{.ID}}Filter, sorting []{{.ID}}Sorting) (*{{.ID}}, error) {
  var err error
  qfilter := []string{}
  args := []any{}
  for _, f := range filter {
    ff, ok := r.findFilters[f.Field]
    if !ok {
      return nil, fmt.Errorf("field %v is not filterable", f.Field)
    }
    qfilter, args, err = ff(qfilter, args, f.Op, f.Value)
    if err != nil {
      slog.Error("Filter", "field", f.Field, "op", f.Op, "value", string(f.Value), "Error", err)
      return nil, err
    }
  }
  qry := `
    SELECT
      `+r.qrySelectObj()+`
    FROM
      `+r.qryFromObj()
  if len(qfilter) > 0 {
    qry += "\n    WHERE " + strings.Join(qfilter, " AND\n      ")
  }
  if len(sorting) > 0 {
    sorts := []string{}
    for _, f := range sorting {
      ff, ok := r.fields[f.Field]
      if !ok {
        return nil, fmt.Errorf("field %v is unsortable", f.Field)
      }
      switch f.Dir {
      case SortDir_ASC:
        sorts = append(sorts, fmt.Sprintf("obj.%s ASC", ff))
      case SortDir_DESC:
        sorts = append(sorts, fmt.Sprintf("obj.%s DESC", ff))
      default:
        return nil, fmt.Errorf("invalid sort direction %v", f.Dir)
      }
    }
    if len(sorts) > 0 {
      qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  qry += "\n  LIMIT 1"
	slog.Debug("store.{{.ID}}.FindOne", logQueryArgs(qry, args, nil)...)
  rows, err := r.{{.DB}}.QueryContext(ctx, qry, args...)
  if err != nil {
    slog.Warn("store.{{.ID}}.FindOne", logQueryArgs(qry, args, err)...)
    return nil, err
  }
  defer rows.Close()
  if rows.Next() {
    var obj {{.ID}};
    err = r.scanObj(&obj, rows)
    if err != nil {
      slog.Warn("store.{{.ID}}.FindOne.Scan", logQueryArgs(qry, args, err)...)
      return nil, err
    }
    return &obj, nil
  }
  return nil, fmt.Errorf("not found")
}

func (r *{{.ID}}StoreImpl) Find(ctx context.Context, filter []{{.ID}}Filter, sorting []{{.ID}}Sorting, limit int, offset int64) ([]{{.ID}}, int64, error) {
  var err error
  qfilter := []string{}
  args := []any{}
  for _, f := range filter {
    ff, ok := r.findFilters[f.Field]
    if !ok {
      return nil, 0, fmt.Errorf("field %v is not filterable", f.Field)
    }
    qfilter, args, err = ff(qfilter, args, f.Op, f.Value)
    if err != nil {
      slog.Error("Filter", "field", f.Field, "op", f.Op, "value", string(f.Value), "Error", err)
      return nil, 0, err
    }
  }
  qry := `SELECT `+r.qrySelectCountObj()+` FROM `+r.qryFromObj()
  if len(qfilter) > 0 {
    qry += " WHERE " + strings.Join(qfilter, " AND ")
  }
	slog.Debug("store.{{.ID}}.FindCount", logQueryArgs(qry, args, nil)...)
  total := int64(0)
  err = r.{{.DB}}.QueryRowContext(ctx, qry, args...).Scan(&total)
  if err != nil {
    slog.Error("Query count", "qry", qry, "Error", err)
    return nil, 0, err
  }
  qry = `
    SELECT
      `+r.qrySelectObj()+`
    FROM
      `+r.qryFromObj()
  if len(qfilter) > 0 {
    qry += "\n    WHERE " + strings.Join(qfilter, " AND\n      ")
  }
  if len(sorting) > 0 {
    sorts := []string{}
    for _, f := range sorting {
      ff, ok := r.fields[f.Field]
      if !ok {
        return nil, 0, fmt.Errorf("field %v is unsortable", f.Field)
      }
      switch f.Dir {
      case SortDir_ASC:
        sorts = append(sorts, fmt.Sprintf("obj.%s ASC", ff))
      case SortDir_DESC:
        sorts = append(sorts, fmt.Sprintf("obj.%s DESC", ff))
      default:
        return nil, 0, fmt.Errorf("invalid sort direction %v", f.Dir)
      }
    }
    if len(sorts) > 0 {
      qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  qry += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
	slog.Debug("store.{{.ID}}.Find", logQueryArgs(qry, args, nil)...)
  rows, err := r.{{.DB}}.QueryContext(ctx, qry, args...)
  if err != nil {
    slog.Warn("store.{{.ID}}.Find", logQueryArgs(qry, args, err)...)
    return nil, 0, err
  }
  defer rows.Close()
  list := []{{.ID}}{};
  for rows.Next() {
    var obj {{.ID}};
    err = r.scanObj(&obj, rows)
    if err != nil {
      slog.Warn("store.{{.ID}}.Find.Scan", logQueryArgs(qry, args, err)...)
      return nil, total, err
    }
    list = append(list, obj)
  }
  return list, total, nil
}

{{- end }}

