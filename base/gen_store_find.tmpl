{{ define "StoreImplFind" -}}
// FILE-b2bab6a74adbe2e8dd47ebdcb76db7c4: model/gen__{{snakeCase .ID}}_store_find.go
// Code generated by apigen. DO NOT EDIT.
// GENERATED: {{now}}

package {{.Package}}

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log/slog"
	"strings"
	"{{.Module}}/util/jsql"
)

func (r *{{.ID}}StoreImpl) FindOne(ctx context.Context, filter []{{.ID}}Filter, sorting []{{.ID}}Sorting) (*{{.ID}}, error) {
  qfilter := []string{}
  args := []any{}
  {{template "FilterOp" (dict "m" . "Res" "nil, " )}}
  qry := `
    SELECT
      {{ template "SelectField" . }}
    FROM
      {{template "SelectFrom" . }}`
  if len(qfilter) > 0 {
    qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
  }
  if len(sorting) > 0 {
    sorts := []string{}
    for _, f := range sorting {
      switch f.Field {
      {{range .Fields }}{{if eq .Type "text" "int" "autoincrement" "timestamp"}}
      case {{.Model.ID}}Field_{{.ID}}:
        if f.Dir == SortDir_ASC {
          sorts = append(sorts, "obj.{{.Field}} ASC")
        } else {
          sorts = append(sorts, "obj.{{.Field}} DESC")
        }
      {{- else if eq .Type "many-to-one"}}{{$fb := .}}
        {{- if eq (len .RefKeys) 1 }}
        {{- range .RefKeys}}{{if eq .Ref.Type "text" "int" "autoincrement" "timestamp" }}
          case {{$fb.Model.ID}}Field_{{$fb.ID}}:
            if f.Dir == SortDir_ASC {
              sorts = append(sorts, "obj{{$fb.ID}}.{{.Ref.Field}} ASC")
            } else {
              sorts = append(sorts, "obj{{$fb.ID}}.{{.Ref.Field}} DESC")
            }
        {{- end}}{{end}}{{end}}
      {{- end}}{{end}}}
    }
    if len(sorts) > 0 {
      qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  qry += "\n  LIMIT 1"
	logQueryArgs("store.{{.ID}}.FindOne", qry, args)
  rows, err := r.{{.DB}}.QueryContext(ctx, qry, args...)
  if err != nil {
	  logErrorQueryArgs("store.{{.ID}}.FindOne", qry, args)
    return nil, err
  }
  defer rows.Close()
  if rows.Next() {
    var obj {{.ID}};
    {{template "ScanFieldDef" .}}
    err = rows.Scan(
      {{- template "ScanField" . }}
    )
    if err != nil {
	    logErrorQueryArgs("store.{{.ID}}.FindOne.Scan", qry, args)
      return nil, err
    }
    {{- template "GetScanFieldPost" . }}
    {{- template "ScanFieldRef" .}}
    return &obj, nil
  }
  return nil, fmt.Errorf("not found")
}

func (r *{{.ID}}StoreImpl) Find(ctx context.Context, filter []{{.ID}}Filter, sorting []{{.ID}}Sorting, limit int, offset int64) ([]{{.ID}}, int64, error) {
  qfilter := []string{}
  args := []any{}
  {{template "FilterOp" (dict "m" . "Res" "nil, 0, " )}}
  qry := `{{template "QueryFindCount" .}}`
  if len(qfilter) > 0 {
    qry += " WHERE " + strings.Join(qfilter, " AND ")
  }
	logQueryArgs("store.{{.ID}}.FindCount", qry, args)
  total := int64(0)
  err := r.{{.DB}}.QueryRowContext(ctx, qry, args...).Scan(&total)
  if err != nil {
    slog.Error("Query count", "qry", qry, "Error", err)
    return nil, 0, err
  }
  qry = `SELECT
      {{ template "SelectField" . }}
    FROM
      {{template "SelectFrom" . }}`
  if len(qfilter) > 0 {
    qry += "\n  WHERE " + strings.Join(qfilter, " AND\n    ")
  }
  if len(sorting) > 0 {
    sorts := []string{}
    for _, f := range sorting {
      switch f.Field {
      {{range .Fields }}{{if eq .Type "text" "int" "autoincrement" }}
      case {{.Model.ID}}Field_{{.ID}}:
        if f.Dir == SortDir_ASC {
          sorts = append(sorts, "obj.{{.Field}} ASC")
        } else {
          sorts = append(sorts, "obj.{{.Field}} DESC")
        }
      {{- else if eq .Type "many-to-one"}}{{$fb := .}}
        {{- if eq (len .RefKeys) 1 }}
        {{- range .RefKeys}}{{if eq .Ref.Type "text" "int" "autoincrement" "timestamp" }}
          case {{$fb.Model.ID}}Field_{{$fb.ID}}:
            if f.Dir == SortDir_ASC {
              sorts = append(sorts, "obj{{$fb.ID}}.{{.Ref.Field}} ASC")
            } else {
              sorts = append(sorts, "obj{{$fb.ID}}.{{.Ref.Field}} DESC")
            }
        {{- end}}{{end}}{{end}}
      {{- end}}{{end}}
      default:
        return nil, 0, fmt.Errorf("field %v is unsorted", f)
      }
    }
    if len(sorts) > 0 {
      qry += "\n  ORDER BY " + strings.Join(sorts, ", ")
    }
  }
  qry += fmt.Sprintf("\n  LIMIT %d OFFSET %d", limit, offset)
	logQueryArgs("store.{{.ID}}.Find", qry, args)
  rows, err := r.{{.DB}}.QueryContext(ctx, qry, args...)
  if err != nil {
	  logErrorQueryArgs("store.{{.ID}}.Find", qry, args)
    return nil, 0, err
  }
  defer rows.Close()
  list := []{{.ID}}{};
  for rows.Next() {
    var obj {{.ID}};
    {{template "ScanFieldDef" .}}
    err = rows.Scan(
      {{- template "ScanField" . }}
    )
    if err != nil {
	    logErrorQueryArgs("store.{{.ID}}.Find.Scan", qry, args)
      return nil, total, err
    }
    {{- template "GetScanFieldPost" . }}
    {{- template "ScanFieldRef" .}}
    list = append(list, obj)
  }
  return list, total, nil
}
{{- end }}

{{define "QueryFindCount" -}}
  SELECT COUNT(DISTINCT
  {{ $idx := 0}}{{range .PKeys -}}{{- if gt $idx 0}}, {{end}}{{$idx = add $idx 1}}obj.{{.Field -}}
  {{- end}}) FROM {{template "SelectFrom" . }}
{{- end -}}

{{define "FilterOp_ILike" -}}
	var val {{.GoType}}
	err := json.Unmarshal(f.Value, &val)
	if err != nil {
    return {{.Args.Res}}err
  }
	args = append(args, val)
  qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} ILIKE {{ template "QryParamArg" .}})
{{- end -}}

{{define "FilterOp" -}}
  {{- $m := .m -}}
  {{- $res := .Res -}}
  for _, f := range filter {
    switch f.Field {
    {{- range .m.Fields -}}{{if eq .Type "text"}}
    case {{$m.ID}}Field_{{.ID}}:
      switch f.Op {
      case FilterOp_EQ:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
        {{- if eq .Case "upper" }}
          val = strings.ToUpper(val)
        {{- else if eq .Case "lower" }}
          val = strings.ToLower(val)
        {{- end}}
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} = {{ template "QryParamArg" .}})
      case FilterOp_Like:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
        {{- if eq .Case "upper" }}
          val = strings.ToUpper(val)
        {{- else if eq .Case "lower" }}
          val = strings.ToLower(val)
        {{- end}}
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} LIKE {{ template "QryParamArg" .}})
      case FilterOp_ILike:
        {{- template "FilterOp_ILike" (fieldArgs . "Res" $res)}}
      default:
        return {{$res}}fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
      }
    {{- else if eq .Type "integer" "timestamp" "date" "time"}}
    case {{$m.ID}}Field_{{.ID}}:
      switch f.Op {
      case FilterOp_EQ:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} = {{ template "QryParamArg" .}})
      case FilterOp_Greater:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} > {{ template "QryParamArg" .}})
      case FilterOp_GreaterEq:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} >= {{ template "QryParamArg" .}})
      case FilterOp_LessEq:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} <= {{ template "QryParamArg" .}})
      case FilterOp_Less:
				var val {{.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj.{{.Field}} < {{ template "QryParamArg" .}})
      default:
        return {{$res}}fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
      }
    {{- else if eq .Type "many-to-one"}}{{$fb := .}}
    {{- if eq (len .RefKeys) 1 }}
    {{- range .RefKeys -}}{{if eq .Ref.Type "text"}}
    case {{$m.ID}}Field_{{.ID}}:
      switch f.Op {
      case FilterOp_EQ:
				var val {{.Ref.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
        {{- if eq .Ref.Case "upper" }}
          val = strings.ToUpper(val)
        {{- else if eq .Ref.Case "lower" }}
          val = strings.ToLower(val)
        {{- end}}
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj{{$fb.ID}}.{{.Field}} = {{ template "QryParamArg" .}})
      case FilterOp_Like:
				var val {{.Ref.GoType}}
				err := json.Unmarshal(f.Value, &val)
				if err != nil {
          return {{$res}}err
        }
        {{- if eq .Ref.Case "upper" }}
          val = strings.ToUpper(val)
        {{- else if eq .Ref.Case "lower" }}
          val = strings.ToLower(val)
        {{- end}}
				args = append(args, val)
        qfilter = append(qfilter, fmt.Sprintf("obj{{$fb.ID}}.{{.Field}} LIKE {{ template "QryParamArg" .}})
      case FilterOp_ILike:
        {{- template "FilterOp_ILike" (fieldArgs .Ref "Res" $res)}}
      default:
        return {{$res}}fmt.Errorf("unsupported filter op %v for field %v", f.Op, f.Field)
      }
    {{- end}}{{end}}{{end}}{{end}}{{end}}
    default:
      return {{$res}}fmt.Errorf("unsupported filter field %v", f.Field)
    }
  }
{{- end -}}

{{- define "PreFindObj"}}
  {{- range .Fields -}}
    {{- if eq .Type "text" }}
      {{- if eq .Case "upper" }}
        {{- "\n    "}}obj.{{.ID}} = strings.ToUpper(obj.{{.ID}}) 
      {{- else if eq .Case "lower" }}
        {{- "\n    "}}obj.{{.ID}} = strings.ToLower(obj.{{.ID}})
      {{- end}}
    {{- end}}
  {{- end}}
 {{- end -}}
